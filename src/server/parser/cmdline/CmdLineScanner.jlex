//
// $Id: CmdLineScanner.jlex,v 2.4.6.1 2013/03/14 10:24:54 ronald Exp $
//
// Copyright (C) 2002 topIT Informationstechnologie GmbH
//
// $Log: CmdLineScanner.jlex,v $
// Revision 2.4.6.1  2013/03/14 10:24:54  ronald
// Umstellung auf standard konforme package bezeichnungen
//
// Revision 2.4  2011/06/02 12:35:02  ronald
// backslash doppelte quote wird nun richtig interpretiert
//
// Revision 2.3  2005/04/13 14:41:27  ronald
// Fehler beim Quoten von Backslashes behoben
//
// Revision 2.2  2004/11/22 09:23:12  ronald
// Eliminated compiler warnings
//
// Revision 2.1  2004/08/20 20:34:41  ronald
// Bug entfernt (Server Abstuerz beim Parsen eines Commandlines mit newlines)
// command separator wird nun auch richtig behandelt
//
// Revision 2.0  2004/04/19 15:25:40  ronald
// Version 2.0 Started
//
// Revision 1.12  2004/02/29 14:15:47  ronald
// Issue 255: Unbalanced Quote handling. The run command and rerun command
// are now checked at create/alter time
//
// Revision 1.11  2004/02/28 07:32:16  ronald
// Bug im "noprivcheck" handling behoben
//
// Revision 1.10  2003/02/09 19:21:22  ronald
// Redesign of Trace System. Use SDMSThread.doTrace() now.
//
// Revision 1.9  2002/11/18 20:03:21  ronald
// Issue 105: Dollars in der Commandline muessen escaped werden koennen
//
// Revision 1.8  2002/11/03 20:27:25  ronald
// Auch backticks werden nun als (single) quotes betrachtet
//
// Revision 1.7  2002/10/22 00:10:48  ronald
// Copyright Zeile ergaenzt
//
// Revision 1.6  2002/07/12 08:21:29  ronald
// 1. versioned list & show
// 2. letzte drittel kill
// 3. Bug in alter job definition
//
// Revision 1.5  2002/07/09 13:50:13  ronald
// Fehler im CmdLineParser (trailing spaces broke the parser)
// Fehler in GetNextJob (If Job -> Error, delete from queue!)
//
// Revision 1.4  2002/06/17 20:41:40  ronald
// Improved commandline parsing and parameter handling
//
// Revision 1.3  2002/05/29 10:37:12  bernhard
// Minor changes to get rid of those annoying warnings
//
// Revision 1.2  2002/02/21 01:11:06  ronald
// Syntax for tree copies, Parameters, Indexes for pg, pg int8-literal problem
//
// Revision 1.1  2002/02/03 20:55:32  ronald
// Commandline Parser zugefuegt
//
//

package de.independit.scheduler.server.parser.cmdline;

import java.io.*;
import de.independit.scheduler.server.util.*;
import de.independit.scheduler.server.exception.*;

%%

%public
%class CmdLineScanner
%implements de.independit.scheduler.server.parser.cmdline.CmdLineParser.yyInput
%type int
%yyeof
%integer

%line
%full

%{
private static boolean debug = false;

public int yyline()
{
	return yyline + 1;
}

private int token;
private Object value;
private boolean eofProhibited = false;

/** move to next token
    @return false if positioned beyond tokens (EOF)
    @throws IOException on input error
*/
public boolean advance() throws 
	java.io.IOException, CommonErrorException
{
	token = yylex();
	if(debug) SDMSThread.doTrace(null, "Token : " + token + "\n", SDMSThread.SEVERITY_DEBUG);
	if(token == YYEOF && eofProhibited)
		throw new CommonErrorException("Unexpected end of string (missing quote?)");
	return (token != YYEOF);
}

private void proto(String s)
{
	if(debug) SDMSThread.doTrace(null, s + "( " + yytext() + " )", SDMSThread.SEVERITY_DEBUG);
}

/** classifies current token
    should not be called if advance() returned false
    @return current %token or single character
*/
public int token()
{
	return token;
}

/** associated with current token
    should not be called after advance() returned false.
    @return value for token();
*/
public Object value() 
{
	return value;
}
%}

// Note: This definition of identifiers conforms to the definition in Parser.jay/Scanner.jlex
alpha	=	[a-zA-Z_#@]
alnum	=	[a-zA-Z_0-9#@]
ws	=	[ \t\n\r\b\015]+
identifier =	{alpha}{alnum}*

%state	DQSTRING SQSTRING BTSTRING VARIABLE DQVARIABLE
%%

//------------------------------------------------------------------------------------------
// Normal Environment, Variables are evaluated, Whitespace is discarded
//

<YYINITIAL>{ws}			{ proto("WS ");			return CmdLineParser.SEPARATOR; }
<YYINITIAL>\'			{				yybegin(SQSTRING); value = new String(""); eofProhibited = true; break; }
<YYINITIAL>`			{				yybegin(BTSTRING); value = new String("`"); eofProhibited = true; break; }
<YYINITIAL>\"			{ proto("DQSTRING_START ");	yybegin(DQSTRING); return CmdLineParser.DQSTRING_START; }
<YYINITIAL>\\			{ proto("\\");			value = new String(yytext()); return CmdLineParser.CHAR; }
<YYINITIAL>\\\\			{ proto("\\\\");		value = new String("\\"); return CmdLineParser.CHAR; }
<YYINITIAL>\\\'			{ proto("SINGLE QUOTE ");	value = new String("\\'"); return CmdLineParser.CHAR; }
<YYINITIAL>\\\"			{ proto("DOUBLE QUOTE ");	value = new String("\""); return CmdLineParser.CHAR; }
<YYINITIAL>\\\$			{ proto("DOLLAR ");		value = new String("$"); return CmdLineParser.CHAR; }
<YYINITIAL>\${identifier}	{ 
					proto("PARAM ");
					value = (yytext().substring(1)).toUpperCase(); 
					return CmdLineParser.PARAM;
				}
<YYINITIAL>\$\{			{ proto("PARAMSTART ");		yybegin(VARIABLE); return CmdLineParser.PARAMSTART; }
<YYINITIAL>.			{ proto("CHAR ");		value = new String(yytext()); return CmdLineParser.CHAR; }


//------------------------------------------------------------------------------------------
// Single Quoted string, no variable evaluation
//

<SQSTRING>\'			{ proto("SQSTRING ");		yybegin(YYINITIAL); eofProhibited = false; return CmdLineParser.SQSTRING; }
<SQSTRING>[^\'\\]*		{				value = ((String) value) + new String(yytext()); break; }
<SQSTRING>\\			{				value = ((String) value) + new String(yytext()); break; }
<SQSTRING>\\\\			{				value = ((String) value) + "\\"; break; }
<SQSTRING>\\\'			{				value = ((String) value) + "'"; break; }


//------------------------------------------------------------------------------------------
// Backticked string, no variable evaluation
//

<BTSTRING>`			{ proto("BTSTRING ");		value = ((String) value) + "`"; 
								yybegin(YYINITIAL); 
								eofProhibited = false; 
								return CmdLineParser.SQSTRING; 
				}
<BTSTRING>[^`\\]*		{				value = ((String) value) + new String(yytext()); break; }
<BTSTRING>\\			{				value = ((String) value) + new String(yytext()); break; }
<BTSTRING>\\\\			{				value = ((String) value) + "\\"; break; }
<BTSTRING>\\`			{				value = ((String) value) + "\\`"; break; }


//------------------------------------------------------------------------------------------
// Double Quoted String, Variables are evaluated, Whitespace matters
//

<DQSTRING>\"			{ proto("DQSTRING_END ");	yybegin(YYINITIAL); return CmdLineParser.DQSTRING_END; }
<DQSTRING>\$\{			{ proto("PARAMSTART ");		yybegin(DQVARIABLE); return CmdLineParser.PARAMSTART; }
<DQSTRING>\\\$			{ proto("DOLLAR ");		value = new String("$"); return CmdLineParser.CHAR; }
<DQSTRING>\${identifier}	{ 
					proto("PARAM ");
					value = (yytext().substring(1)).toUpperCase(); 
					return CmdLineParser.PARAM; 
				}
<DQSTRING>\\\"			{ proto("CHAR(\") ");		value = new String("\""); return CmdLineParser.CHAR; }
<DQSTRING>\\\\			{ proto("CHAR(\\) ");		value = new String("\\"); return CmdLineParser.CHAR; }
<DQSTRING>.			{ proto("CHAR ");		value = new String(yytext()); return CmdLineParser.CHAR; }
<DQSTRING>{ws}			{ proto("CHAR ");		value = new String(yytext()); return CmdLineParser.CHAR; }


//------------------------------------------------------------------------------------------
// Variable Environment, started from YYINITIAL state
// Identifiers may be quoted, to make them case sensitiv

<VARIABLE>\}			{ proto("PARAMEND ");		yybegin(YYINITIAL); return CmdLineParser.PARAMEND; }
<VARIABLE>{identifier}		{ proto("SQSTRING ");		value = yytext().toUpperCase(); return CmdLineParser.SQSTRING; }
<VARIABLE>\'{identifier}\'	{ proto("SQSTRING ");		value = (yytext().substring(1, yytext().length() - 1));
				  return CmdLineParser.SQSTRING;
				}
<VARIABLE>\.			{ proto("DOT ");		return CmdLineParser.DOT; }
<VARIABLE>.			{ proto("CHAR ");		value = new String(yytext()); return CmdLineParser.CHAR; }

//------------------------------------------------------------------------------------------
// Variable Environment, started from DQSTRING state
// Identifiers may be quoted, to make them case sensitive

<DQVARIABLE>\}			{ proto("PARAMEND ");		yybegin(DQSTRING); return CmdLineParser.PARAMEND; }
<DQVARIABLE>{identifier}	{ proto("SQSTRING ");		value = yytext().toUpperCase(); return CmdLineParser.SQSTRING; }
<DQVARIABLE>\'{identifier}\'	{ proto("SQSTRING ");		value = (yytext().substring(1, yytext().length() - 1));
				  return CmdLineParser.SQSTRING;
				}
<DQVARIABLE>\.			{ proto("DOT ");		return CmdLineParser.DOT; }
<DQVARIABLE>.			{ proto("CHAR ");		value = new String(yytext()); return CmdLineParser.CHAR; }

//------------------------------------------------------------------------------------------

//
// End of File
//
