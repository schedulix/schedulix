%{
//
// $Id: ExprParser.jay,v 1.8.14.1 2013/03/14 10:25:16 ronald Exp $
//
// Copyright (C) 2004 independIT Integrative Technologies GmbH
//
//

package de.independit.scheduler.server.parser.triggerexpr;

import java.io.*;
import java.util.*;
import java.lang.*;
import java.math.*;
import java.text.*;
import de.independit.scheduler.server.repository.*;
import de.independit.scheduler.server.exception.*;
import de.independit.scheduler.server.parser.*;
import de.independit.scheduler.server.output.*;
import de.independit.scheduler.server.util.*;
import de.independit.scheduler.server.*;

public class ExprParser 
{

	private int stop = 0;
	private SDMSSubmittedEntity sme = null;
	private SDMSSubmittedEntity requiredSme = null;
	private SDMSResource r = null;
	private SDMSTrigger t = null;
	private SDMSTriggerQueue tq = null;
	private SystemEnvironment sysEnv = null;
	private SDMSScope evalScope = null;
	public static boolean debug = false;
	public boolean checkOnly = false;

	private ExprExecutor executor = null;
	private boolean executorValid = false;

	private ArrayList<Stmt> prog = new ArrayList<Stmt>(256);
	// we assume that 32 levels of nesting within a question mark operator won't be easily exceeded
	private static final int STACKSIZE = 32;
	private int[] qomStack = new int[STACKSIZE];	// addresses of branch commands that jump to the else part of the question mark operator
	private int[] qoeStack = new int[STACKSIZE];	// addresses of branch commands that jump to the end of the question mark operator statement
	private int[] andStack = new int[STACKSIZE];	// addresses of branch commands that jump to the end of an OR expression
	private int[] orStack  = new int[STACKSIZE];	// addresses of branch commands that jump to the end of an OR expression
	private int qomNext = 0;			// stackpointer into qomStack
	private int qoeNext = 0;			// stackpointer into qoeStack
	private int andNext = 0;			// stackpointer into orStack
	private int orNext  = 0;			// stackpointer into orStack

	// Standard Statements that are used very often
	static final Stmt StmtNOP    = new Stmt(Stmt.S_NOP);
	static final Stmt StmtEOP    = new Stmt(Stmt.S_EOP);
	static final Stmt StmtPUSH[] = { new Stmt(Stmt.S_PUSH, 0), new Stmt(Stmt.S_PUSH, 1), new Stmt(Stmt.S_PUSH, 2), new Stmt(Stmt.S_PUSH, 3) };
	static final Stmt StmtPOP[]  = { new Stmt(Stmt.S_POP, 0), new Stmt(Stmt.S_POP, 1), new Stmt(Stmt.S_POP, 2), new Stmt(Stmt.S_POP, 3) };


	static final Integer I_PLUS = Integer.valueOf(278);
	static final Integer I_MINUS = Integer.valueOf(276);

	static final Integer I_TIMES = Integer.valueOf(279);
	static final Integer I_DIV = Integer.valueOf(275);
	static final Integer I_MOD = Integer.valueOf(277);

	static final Integer I_GT = Integer.valueOf(268);
	static final Integer I_GE = Integer.valueOf(269);
	static final Integer I_LT = Integer.valueOf(270);
	static final Integer I_LE = Integer.valueOf(271);
	static final Integer I_EQ = Integer.valueOf(267);
	static final Integer I_NE = Integer.valueOf(272);
	static final Integer I_MATCHES = Integer.valueOf(273);
	static final Integer I_NOMATCH = Integer.valueOf(274);

%}

%token <String>	STRING 257 IDENTIFIER 258 PARAMETER 259 JPARAMETER 260 RPARAMETER 261 TPARAMETER 262 RSPARAMETER 263 DSPARAMETER 264
%token <BigDecimal> NUMBER 265
%token <Boolean> BOOLEAN 266
%token EQ 267 GT 268 GE 269 LT 270 LE 271 NE 272 MATCHES 273 NOMATCH 274
%token DIV 275 MINUS 276 MOD 277 PLUS 278 TIMES 279
%token ABS 280 AND 281 DATE 282 FIELD 283 INT 284 LOWERCASE 285 NOT 286 NVL 287 OR 288 ROUND 289 SUBSTR 290 STR 291 TRIM 292 UPPERCASE 293
/*
%type <ParseObject>	expression function literal
%type <ParseObject>	operand term
%type <Boolean>	booloperand boolterm boolexp
*/
%type <Integer>	addop multop comparison

%start triggerexp

%%
triggerexp:						{ if(stop == 0) return Boolean.TRUE; }
	|	boolexp					{ prog.add(StmtEOP);
							  if (debug) render(prog);
							  ParseObject p = null;
							  // long now = System.currentTimeMillis();
							  if (!checkOnly) {
								p = executor.execute(prog);
								executorValid = true;
							  }
							  // System.out.println("Execution : " + (System.currentTimeMillis() - now) + " ms");
							  if(stop == 0) return p;
							}

boolexp:	boolterm				{ }
	|	boolexp  				{ addPOPorMOV(1);
							  prog.add(new Stmt(Stmt.S_BRT,1,0));
							  orStack[orNext++] = prog.size() - 1;
							  if (orNext == STACKSIZE)
								throw new yyException("Condition too complex");
							  prog.add(StmtPUSH[1]);	/* we've found a False, so we'll have to restore the stack */
							}
		OR boolterm				{ addPOPorMOV(1);
							  addPOPorMOV(2);
							  prog.add(new Stmt(Stmt.S_OR,1,2));
							  prog.add(StmtPUSH[0]);
							  prog.add(new Stmt(Stmt.S_JMP,prog.size()+2));	/* 0 = JMP Statement, 1 = PUSH, 2 = continuation */
							  prog.get(orStack[--orNext]).setAddr(prog.size());
							  prog.add(new Stmt(Stmt.S_PUSHL, Boolean.TRUE));
							  prog.add(StmtNOP);	// block optimizations
							}

boolterm:	booloperand				{ }
	|	boolterm				{ addPOPorMOV(1);
							  prog.add(new Stmt(Stmt.S_BRF,1,0));
							  andStack[andNext++] = prog.size() - 1;
							  if (andNext == STACKSIZE)
								throw new yyException("Condition too complex");
							  prog.add(StmtPUSH[1]);	/* we've found a False, so we'll have to restore the stack */
							}
		AND booloperand				{ addPOPorMOV(1);
							  addPOPorMOV(2);
							  prog.add(new Stmt(Stmt.S_AND,1,2));
							  prog.add(StmtPUSH[0]);
							  prog.add(new Stmt(Stmt.S_JMP,prog.size()+2));	/* 0 = JMP Statement, 1 = PUSH, 2 = continuation */
							  prog.get(andStack[--andNext]).setAddr(prog.size());
							  prog.add(new Stmt(Stmt.S_PUSHL, Boolean.FALSE));
							  prog.add(StmtNOP);	// block optimizations
							}

booloperand:	NOT booloperand				{ addPOPorMOV(1);
							  prog.add(new Stmt(Stmt.S_NOT,1));
							  prog.add(StmtPUSH[0]);
							}
	|	expression comparison expression	{ addPOPorMOV(1);
							  addPOPorMOV(2);
							  prog.add(new Stmt(Stmt.S_CMP,$2,2,1));
							  prog.add(StmtPUSH[0]);
							}
	|	expression				{ }

expression:	term					{ }
	|	expression addop term			{ addPOPorMOV(1);
							  addPOPorMOV(2);
							  prog.add(new Stmt(Stmt.S_ADD,$2,2,1));
							  prog.add(StmtPUSH[0]);
							}

term:		operand					{ }
	|	term multop operand			{ addPOPorMOV(1);
							  addPOPorMOV(2);
							  prog.add(new Stmt(Stmt.S_MULT,$2,2,1));
							  prog.add(StmtPUSH[0]);
							}

addop:		PLUS					{ $$ = I_PLUS; }
	|	MINUS					{ $$ = I_MINUS; }

multop:		TIMES					{ $$ = I_TIMES; }
	|	DIV					{ $$ = I_DIV; }
	|	MOD					{ $$ = I_MOD; }

comparison:	GT					{ $$ = I_GT; }
	|	GE					{ $$ = I_GE; }
	|	LT					{ $$ = I_LT; }
	|	LE					{ $$ = I_LE; }
	|	EQ					{ $$ = I_EQ; }
	|	NE					{ $$ = I_NE; }
	|	MATCHES					{ $$ = I_MATCHES; }
	|	NOMATCH					{ $$ = I_NOMATCH; }

operand:	'(' boolexp ')'				{ }
	|	addop operand				{ if ($1 == I_MINUS) {
								  addPOPorMOV(1);
								  prog.add(new Stmt(Stmt.S_CHGS,1));
								  prog.add(StmtPUSH[0]);
							  }
							}
	|	simpleoperand				{ }
	|	function				{ }
	|	'(' boolexp	{
				    addPOPorMOV(1);
				    prog.add(new Stmt(Stmt.S_BRF,1,0));
				    qomStack[qomNext++] = prog.size() - 1;	/* array is zero based */
				    if (qomNext == STACKSIZE)
					 throw new yyException("Condition too complex");
				}
		'?' expression	{
				    prog.add(new Stmt(Stmt.S_JMP,0));
				    qoeStack[qoeNext++] = prog.size() - 1;
				    if (qoeNext == STACKSIZE)
					throw new yyException("Condition too complex");
				}
		':'		{
				    prog.get(qomStack[--qomNext]).setAddr(prog.size());
				    prog.add(StmtNOP);	// block optimizations
			 	}
		expression ')'	{
				    prog.get(qoeStack[--qoeNext]).setAddr(prog.size());
				    prog.add(StmtNOP);	// block optimizations
				}


simpleoperand:  PARAMETER				{ prog.add(new Stmt(Stmt.S_RESOLVE, $1, PARAMETER));
							  prog.add(StmtPUSH[0]);
							}
	|	JPARAMETER				{ prog.add(new Stmt(Stmt.S_RESOLVE, $1, JPARAMETER));
							  prog.add(StmtPUSH[0]);
							}
	|	RPARAMETER				{ prog.add(new Stmt(Stmt.S_RESOLVE, $1, RPARAMETER));
							  prog.add(StmtPUSH[0]);
							}
	|	TPARAMETER				{ prog.add(new Stmt(Stmt.S_RESOLVE, $1, TPARAMETER));
							  prog.add(StmtPUSH[0]);
							}
	|	RSPARAMETER				{ prog.add(new Stmt(Stmt.S_RESOLVE, $1, RSPARAMETER));
							  prog.add(StmtPUSH[0]);
							}
	|	DSPARAMETER				{ prog.add(new Stmt(Stmt.S_RESOLVE, $1, DSPARAMETER));
							  prog.add(StmtPUSH[0]);
							}
	|	literal					{ }


function:	ABS '(' expression ')'						{ addPOPorMOV(1);
										  prog.add(new Stmt(Stmt.S_ABS,1));
										  prog.add(StmtPUSH[0]);
										}
	|	INT '(' expression ')'						{ addPOPorMOV(1);
										  prog.add(new Stmt(Stmt.S_INT,1));
										  prog.add(StmtPUSH[0]);
										}
//	|	DATE '(' expression ',' expression ')'				{ System.out.println("POP(r1);\nPOP(r2;\nDATE(r1,r2);\nPUSH(r0);"); }
//	|	FIELD '(' IDENTIFIER ')'					{ System.out.println("POP(r1);\nFIELD(r1);\nPUSH(r0);"); }
	|	LOWERCASE '(' expression ')'					{ addPOPorMOV(1);
										  prog.add(new Stmt(Stmt.S_LCASE,1));
										  prog.add(StmtPUSH[0]);
										}
	|	NVL '(' expression ',' expression ')'				{ addPOPorMOV(1);
										  addPOPorMOV(2);
										  prog.add(new Stmt(Stmt.S_NVL,1,2));
										  prog.add(StmtPUSH[0]);
										}
	|	ROUND '(' expression ')'					{ addPOPorMOV(1);
										  prog.add(new Stmt(Stmt.S_ROUND,1));
										  prog.add(StmtPUSH[0]);
										}
	|	STR '(' expression ')'						{ addPOPorMOV(1);
										  prog.add(new Stmt(Stmt.S_STR,1));
										  prog.add(StmtPUSH[0]);
										}
	|	SUBSTR '(' expression ',' expression ',' expression ')'		{ 
										  addPOPorMOV(1);
										  addPOPorMOV(2);
										  addPOPorMOV(3);
										  prog.add(new Stmt(Stmt.S_SUBSTR,3));
										  prog.add(StmtPUSH[0]);
										}
	|	SUBSTR '(' expression ',' expression ')'			{ 
										  addPOPorMOV(1);
										  addPOPorMOV(2);
										  prog.add(new Stmt(Stmt.S_SUBSTR,2));
										  prog.add(StmtPUSH[0]);
										}
	|	TRIM '(' expression ')'						{ addPOPorMOV(1);
										  prog.add(new Stmt(Stmt.S_TRIM,1));
										  prog.add(StmtPUSH[0]);
										}
	|	UPPERCASE '(' expression ')'					{ addPOPorMOV(1);
										  prog.add(new Stmt(Stmt.S_UCASE,1));
										  prog.add(StmtPUSH[0]);
										}

literal:	NUMBER					{ prog.add(new Stmt(Stmt.S_PUSHL,$1)); }
	|	STRING					{ prog.add(new Stmt(Stmt.S_PUSHL,$1)); }
	|	BOOLEAN					{ prog.add(new Stmt(Stmt.S_PUSHL,$1)); }
%%

/* Some helper functions */
	private void addPOPorMOV(int target)
	{
		int ip = prog.size() - 1;
		Stmt s = prog.get(ip);	// get the last Statement
		switch (s.opcode) {
			case Stmt.S_PUSH:
				prog.set(ip, new Stmt(Stmt.S_MOV, s.src, target));
				break;
			case Stmt.S_PUSHL:
				s.opcode = Stmt.S_MOVL;
				s.target = target;
				break;
			case Stmt.S_MOV:
			case Stmt.S_MOVL:
				// we've just coalesced a push/pop pair into a move
				// if the previous statement is a push, we can merge that with our current pop
				s = prog.get(ip - 1);
				if (s.opcode == Stmt.S_PUSH) {
					prog.set(ip-1, new Stmt(Stmt.S_MOV, s.src, target));
					break;
				} else if (s.opcode == Stmt.S_PUSHL) {
					s.opcode = Stmt.S_MOVL;
					s.target = target;
					break;
				} else {
					prog.add(StmtPOP[target]);
				}
				break;
			default:
				prog.add(StmtPOP[target]);
		}
	}

	private void render(ArrayList<Stmt> prog)
	{
		for (int i = 0; i < prog.size(); ++i) {
			System.out.println(i + ":\t" + prog.get(i).toString());
		}
	}

	public void set(SystemEnvironment env, SDMSSubmittedEntity sme, SDMSSubmittedEntity requiredSme, SDMSResource rs, SDMSTrigger tr, SDMSTriggerQueue trq, SDMSScope s)
	{
		this.sysEnv = env;
		this.sme = sme;
		this.requiredSme = requiredSme;
		this.r = rs;
		this.t = tr;
		this.tq = trq;
		this.evalScope = s;
		executor = new ExprExecutor(env, sme, requiredSme, rs, tr, trq, s);
	}

	// a wrapper around yyparse that is guaranteed to return a Boolean
	public Boolean parseBoolExpr(ExprScanner exprs)
		throws java.io.IOException, yyException, SDMSException
	{
		Object p;
		if (executorValid)
			p = executor.execute(prog);
		else
			p = yyparse(exprs);
		if (checkOnly)
			return Boolean.TRUE;
		if (p instanceof Boolean)
			return (Boolean) p;
		ParseObject po = (ParseObject) p;
		po.adjust(ParseObject.BOOLEAN);
		return po.bool;
	}

	// a wrapper around yyparse that is guaranteed to return a public class Object
	public Object parseObjExpr(ExprScanner exprs)
		throws java.io.IOException, yyException, SDMSException
	{
		Object p;
		if (executorValid)
			p = executor.execute(prog);
		else
			p = yyparse(exprs);
		if (checkOnly)
			return Boolean.TRUE;
		ParseObject po = (ParseObject) p;
		return po.toObject();
	}

}

class ParseObject {

	public BigDecimal number;
	public String     string;
	public Boolean    bool;

	public int type;

	public static final int VOID    = 0;
	public static final int STRING  = 1;
	public static final int NUMBER  = 2;
	public static final int DATE    = 3;
	public static final int BOOLEAN = 4;
	public static final int INDETERMINED = 99;	// this is stored as string, but hasn't a definite type yet

	public static final BigDecimal one = new BigDecimal("1");


	public ParseObject()
	{
		type = VOID;
		number = null;
		string = null;
		bool = null;
	}

	public ParseObject(Object o)
	{
		if(o instanceof BigDecimal) {
			type = NUMBER;
			number = (BigDecimal) o;
			string = null;
		} else
		if(o instanceof String) {
			string = (String) o;
			try {
				number = new BigDecimal(string);
				type = NUMBER;
				string = null;
			} catch (NumberFormatException nfe) {
				number = null;
				type = STRING;
			}
		} else
		if (o instanceof Boolean) {
			bool = (Boolean) o;
			type = BOOLEAN;
			number = null;
			string = null;
		} else
		if(o.getClass().getName().endsWith("Something date like")) {
			type = DATE;
			string = null;
			number = null;
		} else {
			// Error
			System.err.println("Fatal Exception! Unexpected Object: " + o.toString() + "\n");
			System.exit(1);
		}
	}

	public String toString()
	{
		if (type == VOID) return "VOID";
		if (type == STRING) return string;
		if (type == NUMBER) return number.toString();
		if (type == BOOLEAN) return bool.toString();
		if (type == INDETERMINED) {
			if (string != null) return string;
		}
		return "Unknown";
	}

	public Object toObject()
	{
		if (type == VOID) return "VOID";
		if (type == STRING) return string;
		if (type == NUMBER) return number;
		if (type == BOOLEAN) return bool;
		if (type == INDETERMINED) {
			if (string != null) return string;
		}
		return "Unknown";
	}

	public ParseObject(BigDecimal d)
	{
		type = NUMBER;
		number = d;
		string = null;
		bool = null;
	}

	public ParseObject(Boolean b)
	{
		type = BOOLEAN;
		number = null;
		string = null;
		bool = b;
	}

	public ParseObject(ParseObject p)
	{
		type = p.type;
		number = p.number;
		string = p.string;
		bool = p.bool;
	}

	public Object getValue()
	{
		if (type == STRING || type == INDETERMINED) return string;
		if (type == NUMBER) {
			if (number == null) return null;
			long v;
			try {
				v = number.longValueExact();
				return Long.valueOf(v);
			} catch (ArithmeticException ae) {
				double d;
				d = number.doubleValue();
				return Double.valueOf(d);
			}
		}
		if (type == BOOLEAN) {
			return bool;
		}
		return null;
	}

	public ParseObject adjust(ParseObject po)
		throws SDMSException
	{
		return adjust(po.type);
	}

	public ParseObject adjust(int t)
		throws SDMSException
	{
		if(type == t) return new ParseObject(this);
		ParseObject rc = new ParseObject(this);
		try {
			switch(t) {
				case INDETERMINED:
				case STRING:
					rc.type = STRING;
					rc.number = null;
					rc.bool = null;
					if (type == NUMBER)	rc.string = number.toString();
					if (type == BOOLEAN)	rc.string = bool.toString();
					if (type == VOID)	rc.string = new String();
					break;
				case NUMBER:
					rc.type = NUMBER;
					rc.string = null;
					rc.bool = null;
					if (type == STRING || type == INDETERMINED)	rc.number = new BigDecimal(string);
					if (type == BOOLEAN)	rc.number = new BigDecimal(bool ? 1 : 0);
					if (type == VOID)	rc.number = new BigDecimal("0");
					break;
				case BOOLEAN:
					rc.type = BOOLEAN;
					rc.number = null;
					rc.string = null;
					if (type == NUMBER)	rc.bool = (number.compareTo(new BigDecimal(0)) != 0);
					if (type == STRING) {
						rc.bool = false;
						if (string != null) {
							String s = string.toUpperCase();
							if (s.equals("TRUE") || s.equals("T"))
								rc.bool = true;
						}
					}
					if (type == BOOLEAN)	rc.bool = bool;
					break;
			}
		} catch (NumberFormatException nfe) {
			// we'd like to convert into a number, but the format isn't valid :-(
			// throwing an error here isn't exactly what we want, but we have no real alternative
			if (string == null || string.equals("") || string.toUpperCase().equals("NONE")) {
				rc.number = new BigDecimal("0");
			} else {
				throw new SDMSException(new SDMSMessage((SystemEnvironment) null, "03802071626", "Error evaluating expression. Invalid number format of $1", string));
			}
		}
		return rc;
	}

	public ParseObject mult(ParseObject o2, Integer s)
		throws SDMSException
	{
		int operator = s.intValue();
		ParseObject op1 = adjust(ParseObject.NUMBER);
		ParseObject op2 = o2.adjust(ParseObject.NUMBER);
		switch(operator) {
			case ExprParser.DIV:
				if (op2.number.equals(0))
					throw new SDMSException(new SDMSMessage((SystemEnvironment) null, "03802071627", "Error evaluating expression. Division by zero"));
				op1.number = op1.number.divide(op2.number, RoundingMode.HALF_UP);
				break;
			case ExprParser.TIMES:	op1.number = op1.number.multiply(op2.number); break;
			case ExprParser.MOD:
				BigInteger n1 = op1.number.toBigInteger();
				BigInteger n2 = op2.number.toBigInteger();
				if (n2.equals(0))
					throw new SDMSException(new SDMSMessage((SystemEnvironment) null, "03802071628", "Error evaluating expression. Division by zero"));
				op1.number = new BigDecimal(n1.mod(n2));
				break;
		}
		return op1;
	}

	public ParseObject add(ParseObject o2, Integer s)
		throws SDMSException
	{
		// adding two parameters (operator == PLUS) is an ambiguous operation
		// a. if "this" is a number and the other operand is too, the result will be a number
		// b. if "this" is a number and the other operand can be converted into a number, the result will be a number, else "this" is converted to a string
		// c. if "this" is a string, the result will be a string
		// d. if "this" is indeterminated, it is tried to interpret it as a number first
		//
		ParseObject op1 = new ParseObject(this);
		ParseObject op2 = null;

		int operator = s.intValue();
		if (operator == ExprParser.PLUS) {
			if (op1.type == INDETERMINED) {
				// here we try to convert to a number format first.
				// if that fails, it must be a string
				// This is case d.
				try {
					op1 = adjust(NUMBER);
				} catch (CommonErrorException cee) {
					op1 = adjust(STRING);
				}
			}
			if(op1.type == STRING) {
				// Case c. or case d. in case of an invalid number format of "this"
				op2 = o2.adjust(STRING);
				op2.string = op1.string + op2.string;
				return op2;
			} else {
				if (o2.type == NUMBER) {
					// Case a.; nothing to do
				} else {
					// Case b.
					try {
						op2 = o2.adjust(NUMBER);
					} catch (CommonErrorException cee) {
						op1 = op1.adjust(STRING);
						op2.string = op1.string + op2.string;
						return op2;
					}
				}
			}
		}
		if (op1.type != NUMBER)
			op1 = adjust(NUMBER);
		op2 = o2.adjust(NUMBER);
		switch(operator) {
			case ExprParser.PLUS:	op1.number = op1.number.add(op2.number); break;
			case ExprParser.MINUS:	op1.number = op1.number.add(op2.number.negate()); break;
		}
		return op1;
	}

	public int compareTo(ParseObject o2)
		throws SDMSException
	{
		ParseObject op1 = this;
		if (type == INDETERMINED) {
			// we don't know what this is, so we try to adjust to the type of the second operand
			if (o2.type != INDETERMINED) {
				try {
					// this will work if o2 is a String, or "this" has a valid numerical format
					op1 = adjust(o2.type);
				} catch (CommonErrorException cee) {
					// it is pretty certain that both aren't equal, but that doesn't play a role
					// this method is simply not allowed to fail
					op1 = adjust(STRING);
				}
			} else {
				// both are undetermined
				// hence we regard them to be strings
				op1 = adjust(STRING);
			}
		}
		ParseObject op2 = o2.adjust(op1.type);
		int val = 0;
		switch(op1.type) {
			case NUMBER: val = op1.number.compareTo(op2.number); break;
			case STRING: val = op1.string.compareTo(op2.string); break;
		}
		return val;
	}

	public ParseObject compare(ParseObject o2, Integer s)
		throws SDMSException
	{
		int operator = s.intValue();
		if(operator == ExprParser.MATCHES || operator == ExprParser.NOMATCH) {
			ParseObject op1 = adjust(STRING);
			ParseObject op2 = o2.adjust(STRING);
			if(operator == ExprParser.MATCHES && op1.string.matches(op2.string)) return new ParseObject(Boolean.TRUE);
			if(operator == ExprParser.NOMATCH && !op1.string.matches(op2.string)) return new ParseObject(Boolean.TRUE);
			return new ParseObject(Boolean.FALSE);
		} else {
			int val = compareTo(o2);
			switch(operator) {
				case ExprParser.EQ:	return new ParseObject(Boolean.valueOf(val == 0));
				case ExprParser.GE:	return new ParseObject(Boolean.valueOf(val >= 0));
				case ExprParser.GT:	return new ParseObject(Boolean.valueOf(val > 0));
				case ExprParser.LE:	return new ParseObject(Boolean.valueOf(val <= 0));
				case ExprParser.LT:	return new ParseObject(Boolean.valueOf(val < 0));
				case ExprParser.NE:	return new ParseObject(Boolean.valueOf(val != 0));
			}
		}
		return new ParseObject(Boolean.TRUE);
	}

	public ParseObject changeSign()
		throws SDMSException
	{
		ParseObject retval = adjust(ParseObject.NUMBER);
		retval.number = retval.number.negate();
		return retval;
	}

	public ParseObject to_int()
		throws SDMSException
	{
		ParseObject retval = adjust(ParseObject.NUMBER);
		retval.number = new BigDecimal(retval.number.toBigInteger());
		return retval;
	}

	public ParseObject to_date(ParseObject format)
		throws SDMSException
	{
		if(type == NUMBER) return this.to_int();
		if(type == VOID) return this;
		ParseObject retval;
		if(format.type == STRING) {
			try {
				SimpleDateFormat sdf;
				if (format.string != null)
					sdf = new SimpleDateFormat(format.string);
				else 
					sdf = (SimpleDateFormat) SystemEnvironment.staticSystemDateFormat.clone();
				Date d = sdf.parse(this.string);
				retval = new ParseObject(new BigDecimal(d.getTime()));
			} catch (ParseException pe) {
				retval = new ParseObject(new BigDecimal(0));
			}
		} else {
			retval = new ParseObject(new BigDecimal(0));
		}
		return retval;
	}

	public ParseObject abs()
		throws SDMSException
	{
		ParseObject retval = adjust(ParseObject.NUMBER);
		retval.number = retval.number.abs();
		return retval;
	}

	public ParseObject round()
		throws SDMSException
	{
		ParseObject retval = adjust(ParseObject.NUMBER);
		retval.number = retval.number.divide(one, RoundingMode.HALF_UP);
		return retval;
	}

	public ParseObject substr(ParseObject v, ParseObject b)
		throws SDMSException
	{
		ParseObject retval = adjust(STRING);
		int von = v.adjust(NUMBER).number.intValue();
		if(b != null) {
			int bis = b.adjust(NUMBER).number.intValue();
			retval.string = retval.string.substring(von, bis);
		} else {
			retval.string = retval.string.substring(von);
		}
		return retval;
	}

	public ParseObject trim()
		throws SDMSException
	{
		ParseObject retval = adjust(STRING);
		retval.string = retval.string.trim();
		return retval;
	}

	public ParseObject uppercase()
		throws SDMSException
	{
		ParseObject retval = adjust(STRING);
		retval.string = retval.string.toUpperCase();
		return retval;
	}

	public ParseObject lowercase()
		throws SDMSException
	{
		ParseObject retval = adjust(STRING);
		retval.string = retval.string.toLowerCase();
		return retval;
	}

	public ParseObject nvl(ParseObject replacement)
		throws SDMSException
	{
		if ((type == VOID) ||
		    (type == STRING && (string == null || string.equals(""))) ||
		    (type == NUMBER && number == null) ||
		    (type == DATE && number == null))
			return new ParseObject(replacement);
		return new ParseObject(this);
	}

	public ParseObject boolAND(ParseObject b)
		throws SDMSException
	{
		ParseObject a = adjust(ParseObject.BOOLEAN);
		if (a.bool)	// if a == true, the value of b will be the result of the expression
			a = b.adjust(ParseObject.BOOLEAN);
		return a;
	}

	public ParseObject boolOR(ParseObject b)
		throws SDMSException
	{
		ParseObject a = adjust(ParseObject.BOOLEAN);
		try {
			if (!a.bool)	// if a == false, the value of b will be the result of the expression
				a = b.adjust(ParseObject.BOOLEAN);
			return a;
		} catch (NullPointerException npe) {
			System.out.println("this:" + this.toString());
			System.out.println("b   :" + b.toString());
			System.out.println("a   :" + a.toString());
			throw npe;
		}
	}

	public ParseObject boolNOT()
		throws SDMSException
	{
		ParseObject a = adjust(ParseObject.BOOLEAN);
		a.bool = !a.bool;
		return a;
	}
}

class Stmt {
	static final int S_AND   =  1;	/* binary operator */
	static final int S_OR    =  2;	/* binary operator */
	static final int S_NOT   =  3;	/* unary operator  */
	static final int S_CMP   =  4;	/* binary operator */
	static final int S_PUSH  =  5;
	static final int S_POP   =  6;
	static final int S_BRF   =  7;	/* branch if top of stack is false */
	static final int S_BRT   =  8;	/* branch if top of stack is true  */
	static final int S_MULT  =  9;	/* binary operator */
	static final int S_ADD   = 10;	/* binary operator */
	static final int S_RESOLVE = 11;	/* Variable resolution, needs scope and name */
	static final int S_ABS   = 12;	/* unary operator  */
	static final int S_DATE  = 13;	/* not yet used    */
	static final int S_FIELD = 14;	/* not yet used    */
	static final int S_INT   = 15;	/* unary operator  */
	static final int S_LCASE = 16;	/* unary operator  */
	static final int S_NVL   = 17;	/* binary operator */
	static final int S_ROUND = 18;	/* unary operator  */
	static final int S_SUBSTR = 19;	/* takes 2 or 3 arguments, String, from [, to ] */
	static final int S_STR   = 20;	/* unary operator  */
	static final int S_TRIM  = 21;	/* unary operator  */
	static final int S_UCASE = 22;	/* unary operator  */
	static final int S_JMP   = 23;	/* unconditional jmp */
	static final int S_MOV   = 24;  /* Move src to target */
	static final int S_PUSHL = 25;  /* push literal    */
	static final int S_CHGS  = 26;  /* change sign */
	static final int S_NOP   = 27;	/* no operation */
	static final int S_MOVL  = 28;	/* move literal */
	static final int S_EOP   = 100;	/* End Of Program  */

	static final int I_PLUS = 278;
	static final int I_MINUS = 276;

	static final int I_TIMES = 279;
	static final int I_DIV = 275;
	static final int I_MOD = 277;

	static final int I_GT = 268;
	static final int I_GE = 269;
	static final int I_LT = 270;
	static final int I_LE = 271;
	static final int I_EQ = 267;
	static final int I_NE = 272;
	static final int I_MATCHES = 273;
	static final int I_NOMATCH = 274;

	static final int PARAMETER   = ExprParser.PARAMETER;
	static final int JPARAMETER  = ExprParser.JPARAMETER;
	static final int RPARAMETER  = ExprParser.RPARAMETER;
	static final int TPARAMETER  = ExprParser.TPARAMETER;
	static final int RSPARAMETER = ExprParser.RSPARAMETER;
	static final int DSPARAMETER = ExprParser.DSPARAMETER;

	public int opcode;
	public int addr;
	public int numargs;
	public String varName;
	public BigDecimal numVal;
	public String strVal;
	public boolean boolVal;
	public int varScope;
	public int operator;
	public int src, target;

	private void initStmt()
	{
		this.addr = 0;
		this.numargs = 0;
		this.varName = null;
		this.varScope = 0;
		this.operator = 0;
		this.src = 0;
		this.target = 0;
		numVal = null;
		strVal = null;
		boolVal = false;
	}

	public Stmt(int opcode)
	{
		// case S_NOP
		// case S_EOP
		this.opcode = opcode;
		initStmt();
	}

	public Stmt(int opcode, int additionalValue)
	{
		this.opcode = opcode;
		initStmt();
		switch(opcode) {
			case S_JMP:
				this.addr = additionalValue;
				break;
			case S_SUBSTR:
				this.numargs = additionalValue;
				break;
			case S_POP:
				this.target = additionalValue;
				break;
			case S_PUSH:
			case S_NOT:
			case S_TRIM:
			case S_UCASE:
			case S_LCASE:
			case S_ABS:
			case S_INT:
			case S_STR:
			case S_ROUND:
			case S_CHGS:
				this.src = additionalValue;
				break;
			default:
				System.err.println("ERROR: no additional int value allowed for statement type " + opcode);
				System.exit(1);
		}
	}

	public Stmt(int opcode, BigDecimal numVal)
	{
		// case S_PUSHL
		this.opcode = opcode;
		initStmt();
		this.numVal = numVal;
	}

	public Stmt(int opcode, Boolean boolVal)
	{
		// case S_PUSHL
		this.opcode = opcode;
		initStmt();
		this.boolVal = boolVal;
	}

	public Stmt(int opcode, String strVal)
	{
		// case S_PUSHL
		this.opcode = opcode;
		initStmt();
		this.strVal = strVal;
	}

	public Stmt(int opcode, BigDecimal numVal, int target)
	{
		// case S_MOVL
		this.opcode = opcode;
		initStmt();
		this.numVal = numVal;
		this.target = target;
	}

	public Stmt(int opcode, Boolean boolVal, int target)
	{
		// case S_MOVL
		this.opcode = opcode;
		initStmt();
		this.boolVal = boolVal;
		this.target = target;
	}

	public Stmt(int opcode, int src, int target)
	{
		this.opcode = opcode;
		initStmt();
		switch (opcode) {
			case S_BRF:
			case S_BRT:
				this.src = src;
				this.addr = target;
				break;
			case S_AND:
			case S_OR:
			case S_MOV:
				this.src = src;
				this.target = target;
				break;
			default:
				System.err.println("ERROR: don't know what to do with two int values for statement type " + opcode);
				System.exit(1);
		}
	}

	public Stmt(int opcode, String name, int scope)
	{
		// case S_RESOLVE
		this.opcode = opcode;
		initStmt();
		switch (opcode) {
			case S_RESOLVE:
				varName = name;
				varScope = scope;
				break;
			case S_MOVL:
				this.strVal = name;
				this.target = scope;
				break;
		}
	}

	public Stmt(int opcode, int operator, int src, int target)
	{
		this.opcode = opcode;
		initStmt();
		switch(opcode) {
			case S_ADD:
			case S_MULT:
			case S_CMP:
				this.operator = operator;
				this.src = src;
				this.target = target;
				break;
			default:
				System.err.println("ERROR: invalid arguments for statement type " + opcode);
				System.exit(1);
		}
	}

	public void setAddr(int addr)
	{
		this.addr = addr;
	}

	public static String opStr(int operator)
	{
		switch(operator) {
			case I_PLUS:	return "PLUS";
			case I_MINUS:	return "MINUS";
			case I_TIMES:	return "TIMES";
			case I_DIV:	return "DIV";
			case I_MOD:	return "MOD";
			case I_GT:	return "GT";
			case I_GE:	return "GE";
			case I_LT:	return "LT";
			case I_LE:	return "LE";
			case I_EQ:	return "EQ";
			case I_NE:	return "NE";
			case I_MATCHES:	return "MATCHES";
			case I_NOMATCH:	return "NOMATCH";
		}
		return "unknown";
	}

	public static String scStr(int scope)
	{
		switch(scope) {
			case PARAMETER:		return "PARAMETER";
			case JPARAMETER:	return "JPARAMETER";
			case RPARAMETER:	return "RPARAMETER";
			case TPARAMETER:	return "TPARAMETER";
			case RSPARAMETER:	return "RSPARAMETER";
			case DSPARAMETER:	return "DSPARAMETER";
		}
		return "unknown";
	}

	public String toString()
	{
		switch (opcode) {
			case S_AND:	return "AND(r" + src + ",r" + target + ")";
			case S_OR:	return "OR(r" + src + ",r" + target + ")";
			case S_NOT:	return "NOT(r" + src + ")";
			case S_CMP:	return "CMP(" + opStr(operator) + ",r" + src + ",r" + target + ")";
			case S_PUSH:	return "PUSH(r" + src + ")";
			case S_POP:	return "POP(r" + target + ")";
			case S_BRF:	return "BRF(r" + src + ","+ addr + ")";
			case S_BRT:	return "BRT(r" + src + ","+ addr + ")";
			case S_MULT:	return "MULT(" + opStr(operator) + ",r" + src + ",r" + target + ")";
			case S_ADD:	return "ADD(" + opStr(operator) + ",r" + src + ",r" + target + ")";
			case S_RESOLVE:	return "RESOLVE(" + varName + ", " + scStr(varScope) + ")";
			case S_ABS:	return "ABS(r" + src + ")";
			case S_DATE:	return "DATE(r" + src + ")";
			case S_FIELD:	return "FIELD";
			case S_INT:	return "INT(r" + src + ")";
			case S_LCASE:	return "LCASE(r" + src + ")";
			case S_NVL:	return "NVL";
			case S_ROUND:	return "ROUND(r" + src + ")";
			case S_SUBSTR:	return "SUBSTR(" + numargs + ")";
			case S_STR:	return "STR(r" + src + ")";
			case S_TRIM:	return "TRIM(r" + src + ")";
			case S_UCASE:	return "UCASE(r" + src + ")";
			case S_JMP:	return "JMP(" + addr + ")";
			case S_MOV:	return "MOV(r" + src + ",r" + target + ")";
			case S_MOVL:	return "MOVL(" + (strVal == null ? (numVal == null ? boolVal : numVal) : strVal) + ",r" + target + ")";
			case S_PUSHL:	return "PUSHL(" + (strVal == null ? (numVal == null ? boolVal : numVal) : strVal) + ")";
			case S_CHGS:	return "CHGS(r" + src + ")";
			case S_EOP:	return "EOP";
			case S_NOP:	return "NOP";
		}
		return null;
	}
}

class ExprExecutor {

	static final int STACKSIZE = 32;
	static final int NUMREGS = 4;

	private static final String emptyString = "";

	// Names of Trigger Variables
	public static final String S_TIMES_CHECKED = "TIMES_CHECKED";
	public static final String S_TIMES_FIRED   = "TIMES_FIRED";

	/* Execution contect */
	ParseObject[] stack;
	ParseObject[] regs;
	int ip;	/* instruction pointer */
	int sp;	/* stack pointer; points to top of stack + 1 (next stackentry) */

	/* Execution environment */
	private SDMSSubmittedEntity sme = null;
	private SDMSSubmittedEntity requiredSme = null;
	private SDMSResource r = null;
	private SDMSTrigger t = null;
	private SDMSTriggerQueue tq = null;
	private SystemEnvironment sysEnv = null;
	private SDMSScope evalScope = null;

	// private HashMap<SDMSKey,ParseObject> cache = new HashMap<SDMSKey,ParseObject>();


	public ExprExecutor(SystemEnvironment sysEnv, SDMSSubmittedEntity sme, SDMSSubmittedEntity requiredSme,
		SDMSResource r, SDMSTrigger t, SDMSTriggerQueue tq, SDMSScope evalScope)
	{
		stack = new ParseObject[STACKSIZE];
		regs = new ParseObject[NUMREGS];
		ip = 0;
		sp = 0;

		/* set up execution environment */
		this.sysEnv = sysEnv;
		this.sme = sme;
		this.requiredSme = requiredSme;
		this.r = r;
		this.t = t;
		this.tq = tq;
		this.evalScope = evalScope;
	}

	private ParseObject resolve(String o, int type)
		throws SDMSException
	{
		// SDMSKey k = new SDMSKey(o,type);
		// ParseObject result = cache.get(k);
		// if (result != null) return result;
		String p = emptyString;
		switch (type) {
			case ExprParser.JPARAMETER:
				p = sme.getVariableValue(sysEnv, o, false, ParseStr.S_LIBERAL, true /* triggercontext */, evalScope, true);
				break;
			case ExprParser.RPARAMETER:
				if (r != null)
					p = r.getVariableValue(sysEnv, o, true);
				break;
			case ExprParser.TPARAMETER:
				p = resolveTriggerVariable(o);
				if (p == null) p = emptyString;
				break;
			case ExprParser.RSPARAMETER:
				if (requiredSme != null)
					p = requiredSme.getVariableValue(sysEnv, o, false, ParseStr.S_LIBERAL, true /* triggercontext */, evalScope, true);
				else
					p = sme.getVariableValue(sysEnv, o, false, ParseStr.S_LIBERAL, true /* triggercontext */, evalScope, true);
				break;
			case ExprParser.DSPARAMETER:
				p = sme.getVariableValue(sysEnv, o, false, ParseStr.S_LIBERAL, true /* triggercontext */, evalScope, true);
				break;
			case ExprParser.PARAMETER:
				p = resolveTriggerVariable(o);
				if(p != null) return new ParseObject(p);
				if(sme != null) {
					p = sme.getVariableValue(sysEnv, o, false, ParseStr.S_LIBERAL, true /* triggercontext */, evalScope, true);
				} else {
					if (requiredSme != null) 
						p = requiredSme.getVariableValue(sysEnv, o, false, ParseStr.S_LIBERAL, true /* triggercontext */, evalScope, true);
					else
						if (r != null)
							p = r.getVariableValue(sysEnv, o, true);
						else
							p = emptyString;
				}
				break;
		}
		return new ParseObject(p);
	}
	public String resolveTriggerVariable(String key)
	{
		if(tq == null) return null;
		try {
			if(key.equals(S_TIMES_CHECKED)) {
				return tq.getTimesChecked(sysEnv).toString();
			}
			if(key.equals(S_TIMES_FIRED)) {
				return tq.getTimesTriggered(sysEnv).toString();
			}
		} catch(SDMSException e) { /* ignore */ }
		return null;
	}

	private void printHeader()
	{
		System.out.print("\t\t\t\t");
		for (int i = 0; i < STACKSIZE/4; ++i) {
			System.out.print("s[" + i + "]\t");
		}
		System.out.print("\t");
		for (int i = 0; i < NUMREGS; ++i) {
			System.out.print("r" + i + "\t");
		}
		System.out.println();
	}

	private void printState(Stmt s)
	{
		String str = s.toString();
		int l = (3 - str.length()/8) + 1;
		for (;l>0;--l) str = str + "\t";
		System.out.print(str);

		for (int i = 0; i < STACKSIZE/4; ++i) {
			if (i >= sp)
				System.out.print("-\t");
			else
				System.out.print(stack[i].toString() + "\t");
		}
		System.out.print("\t");
		for (int i = 0; i < NUMREGS; ++i) {
			if (regs[i] == null)
				System.out.print("-\t");
			else
				System.out.print(regs[i].toString() + "\t");
		}
		System.out.println();
	}


	public ParseObject execute(ArrayList<Stmt> prog)
		throws SDMSException
	{
		int parVal = 1;		// for debugging
		ParseObject p = null;
		if (ExprParser.debug)
			printHeader();
		int last = prog.size();
		while (ip < last) {
			Stmt s = prog.get(ip);
			switch (s.opcode) {
				case Stmt.S_AND:
					regs[0] = regs[s.src].boolAND(regs[s.target]);
					break;
				case Stmt.S_OR:
					regs[0] = regs[s.src].boolOR(regs[s.target]);
					break;
				case Stmt.S_NOT:
					regs[0] = regs[s.src].boolNOT();
					break;
				case Stmt.S_CMP:
					/* return "CMP(" + opStr(operator) + ",r" + src + ",r" + target + ")"; */
					regs[0] = regs[s.src].compare(regs[s.target],s.operator);
					break;
				case Stmt.S_PUSH:
					if (sp == STACKSIZE) {
						throw new StackOverflowError("Stack overflow at statement " + ip);
					}
					stack[sp] = regs[s.src];
					sp++;
					break;
				case Stmt.S_POP:
					if (sp == 0) {
						throw new StackOverflowError("Stack underflow at statement " + ip);
					}
					sp--;
					regs[s.target] = stack[sp];
					break;
				case Stmt.S_BRF:
					p = regs[s.src];
					if (p.type != ParseObject.BOOLEAN) {
						p = p.adjust(ParseObject.BOOLEAN);
					}
					if (!p.bool) {
						ip = s.addr - 1;	/* subtract one, it is corrected after the switch */
					}
					break;
				case Stmt.S_BRT:
					p = regs[s.src];
					if (p.type != ParseObject.BOOLEAN) {
						p = p.adjust(ParseObject.BOOLEAN);
					}
					if (p.bool) {
						ip = s.addr - 1;	/* subtract one, it is corrected after the switch */
					}
					break;
				case Stmt.S_MULT:
					regs[0] = regs[s.src].mult(regs[s.target], s.operator);
					break;
				case Stmt.S_ADD:
					regs[0] = regs[s.src].add(regs[s.target], s.operator);
					break;
				case Stmt.S_RESOLVE:
					/* for testing */
					/* regs[0] = new ParseObject(new BigDecimal(parVal++)); */
					regs[0] =  resolve(s.varName, s.varScope);
					break;
				case Stmt.S_ABS:
					regs[0] = regs[s.src].abs();
					break;
				case Stmt.S_DATE:
					/* return "DATE"; */
					break;
				case Stmt.S_FIELD:
					/* return "FIELD"; */
					break;
				case Stmt.S_INT:
					regs[0] = regs[s.src].to_int();
					break;
				case Stmt.S_LCASE:
					regs[0] = regs[s.src].lowercase();
					break;
				case Stmt.S_NVL:
					regs[0] = regs[s.src].nvl(regs[s.target]);
					break;
				case Stmt.S_ROUND:
					regs[0] = regs[s.src].round();
					break;
				case Stmt.S_SUBSTR:
					/* return "SUBSTR(" + numargs + ")"; */
					if (s.numargs == 2)
						regs[0] = regs[2].substr(regs[1], null);
					else
						regs[0] = regs[3].substr(regs[2], regs[1]);
					break;
				case Stmt.S_STR:
					regs[0] = regs[s.src].adjust(ParseObject.STRING);
					break;
				case Stmt.S_TRIM:
					regs[0] = regs[s.src].trim();
					break;
				case Stmt.S_UCASE:
					regs[0] = regs[s.src].uppercase();
					break;
				case Stmt.S_JMP:
					ip = s.addr - 1;	/* subtract one, it is corrected after the switch */
					break;
				case Stmt.S_MOV:
					regs[s.target] = regs[s.src];
					break;
				case Stmt.S_MOVL:
					p = new ParseObject(s.strVal == null ? (s.numVal == null ? s.boolVal : s.numVal) : s.strVal);
					regs[s.target] = p;
					break;
				case Stmt.S_PUSHL:
					if (sp == STACKSIZE) {
						throw new StackOverflowError("Stack overflow at statement " + ip);
					}
					p = new ParseObject(s.strVal == null ? (s.numVal == null ? s.boolVal : s.numVal) : s.strVal);
					stack[sp] = p;
					sp++;
					break;
				case Stmt.S_CHGS:
					regs[0] = regs[s.src].changeSign();
					break;
				case Stmt.S_EOP:	/* should be the last instruction anyway, but better be safe than sorry */
					ip = last;
					break;
				case Stmt.S_NOP:	/* do nothing */
					break;
			}
			if (ExprParser.debug)
				printState(s);
			ip++;
		}
		if (sp != 1) {
			System.out.println("Stack corrupted. sp = " + sp);
			for (int i = 0; i < sp; ++i)
				System.out.println(i + " : " + stack[i]);
		}
		return stack[0];
	}
}

