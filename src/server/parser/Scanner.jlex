//
// Scanner.jlex
//
// Copyright (C) 2001,2002 topIT Informationstechnologie GmbH
// Copyright (C) 2003,2013 independIT Integrative Technologies GmbH
//
//

package de.independit.scheduler.server.parser;

import java.io.*;
import java.util.*;
import java.text.SimpleDateFormat;

import de.independit.scheduler.server.*;
import de.independit.scheduler.server.util.*;
import de.independit.scheduler.server.exception.*;

%%

%public
%class Scanner
%implements de.independit.scheduler.server.parser.Parser.yyInput
%yyeof
%integer

// % line
// % char
// % full

%unicode

%init{
	tokens = new HashMap();

	tokens.put("ACTION",		Integer.valueOf(Parser.ACTION));
	tokens.put("ACTIVE",		Integer.valueOf(Parser.ACTIVE));
	tokens.put("ACTIVATE",		Integer.valueOf(Parser.ACTIVATE));
	tokens.put("ADD",		Integer.valueOf(Parser.ADD));
	tokens.put("AFTER",		Integer.valueOf(Parser.AFTER));
	tokens.put("AGING",		Integer.valueOf(Parser.AGING));
	tokens.put("ALIAS",		Integer.valueOf(Parser.ALIAS));
	tokens.put("ALL",		Integer.valueOf(Parser.ALL));
	tokens.put("ALL_FINAL",		Integer.valueOf(Parser.ALL_FINAL));
	tokens.put("ALTER",		Integer.valueOf(Parser.ALTER));
	tokens.put("AMOUNT",		Integer.valueOf(Parser.AMOUNT));
	tokens.put("AND",		Integer.valueOf(Parser.AND));
	tokens.put("APPROVAL",		Integer.valueOf(Parser.APPROVAL));
	tokens.put("APPROVALS",		Integer.valueOf(Parser.APPROVAL));
	tokens.put("APPROVE",		Integer.valueOf(Parser.APPROVE));
	tokens.put("AT",		Integer.valueOf(Parser.AT));
	tokens.put("ANY",		Integer.valueOf(Parser.ANY));
	tokens.put("AUDIT",		Integer.valueOf(Parser.AUDIT));
	tokens.put("AUTHENTICATED",	Integer.valueOf(Parser.AUTHENTICATED));
	tokens.put("AVG",		Integer.valueOf(Parser.AVG));
	tokens.put("BACKUP",		Integer.valueOf(Parser.BACKUP));
	tokens.put("BASE",		Integer.valueOf(Parser.BASE));
	tokens.put("BATCH",		Integer.valueOf(Parser.BATCH));
	tokens.put("BEFORE",		Integer.valueOf(Parser.BEFORE));
	tokens.put("BETWEEN",		Integer.valueOf(Parser.BETWEEN));
	tokens.put("BROKEN",		Integer.valueOf(Parser.BROKEN));
	tokens.put("BOTH",		Integer.valueOf(Parser.BOTH));
	tokens.put("BY",		Integer.valueOf(Parser.BY));
	tokens.put("CALENDAR",		Integer.valueOf(Parser.CALENDAR));
	tokens.put("CANCEL",		Integer.valueOf(Parser.CANCEL));
	tokens.put("CANCELLED",		Integer.valueOf(Parser.CANCELLED));
	tokens.put("CASCADE",		Integer.valueOf(Parser.CASCADE));
	tokens.put("CATEGORIES",	Integer.valueOf(Parser.CATEGORY));
	tokens.put("CATEGORY",		Integer.valueOf(Parser.CATEGORY));
	tokens.put("CHANGE",		Integer.valueOf(Parser.CHANGE));
	tokens.put("CHECK",		Integer.valueOf(Parser.CHECK));
	tokens.put("CHILD",		Integer.valueOf(Parser.CHILD));
	tokens.put("CHILDREN",		Integer.valueOf(Parser.CHILDREN));
	tokens.put("CHILDSUSPEND",	Integer.valueOf(Parser.CHILDSUSPEND));
	tokens.put("CHILDTAG",		Integer.valueOf(Parser.CHILDTAG));
	tokens.put("CLEANUP",		Integer.valueOf(Parser.CLEANUP));
	tokens.put("CLEAR",		Integer.valueOf(Parser.CLEAR));
	tokens.put("CLONE",		Integer.valueOf(Parser.CLONE));
	tokens.put("COMMAND",		Integer.valueOf(Parser.COMMAND));
	tokens.put("COMMENT",		Integer.valueOf(Parser.COMMENT));
	tokens.put("CONDENSED",		Integer.valueOf(Parser.CONDENSED));
	tokens.put("CONDITION",		Integer.valueOf(Parser.CONDITION));
	tokens.put("CONFIG",		Integer.valueOf(Parser.CONFIG));
	tokens.put("CONNECT",		Integer.valueOf(Parser.CONNECT));
	tokens.put("CONSTANT",		Integer.valueOf(Parser.CONSTANT));
	tokens.put("CONTENT",		Integer.valueOf(Parser.CONTENT));
	tokens.put("CONTINUE",		Integer.valueOf(Parser.CONTINUE));
	tokens.put("COPY",		Integer.valueOf(Parser.COPY));
	tokens.put("COUNT",		Integer.valueOf(Parser.COUNT));
	tokens.put("CREATE",		Integer.valueOf(Parser.CREATE));
	tokens.put("CYCLE",		Integer.valueOf(Parser.CYCLE));
	tokens.put("DAY",		Integer.valueOf(Parser.DAY));
	tokens.put("DAYS",		Integer.valueOf(Parser.DAY));
	tokens.put("DEFAULT",		Integer.valueOf(Parser.DEFAULT));
	tokens.put("DEFER",		Integer.valueOf(Parser.DEFER));
	tokens.put("DEFINITION",	Integer.valueOf(Parser.DEFINITION));
	tokens.put("DEFINITIONS",	Integer.valueOf(Parser.DEFINITION));
	tokens.put("DELAY",		Integer.valueOf(Parser.DELAY));
	tokens.put("DELETE",		Integer.valueOf(Parser.DELETE));
	tokens.put("DEPENDENCIES",	Integer.valueOf(Parser.DEPENDENCY));
	tokens.put("DEPENDENCY",	Integer.valueOf(Parser.DEPENDENCY));
	tokens.put("DEPLOY",		Integer.valueOf(Parser.DEPLOY));
	tokens.put("DEREGISTER",	Integer.valueOf(Parser.DEREGISTER));
	tokens.put("DIR",		Integer.valueOf(Parser.DIR));
	tokens.put("DISABLE",		Integer.valueOf(Parser.DISABLE));
	tokens.put("DISCONNECT",	Integer.valueOf(Parser.DISCONNECT));
	tokens.put("DISPATCH",		Integer.valueOf(Parser.DISPATCH));
	tokens.put("DISTRIBUTION",	Integer.valueOf(Parser.DISTRIBUTION));
	tokens.put("DROP",		Integer.valueOf(Parser.DROP));
	tokens.put("DUMP",		Integer.valueOf(Parser.DUMP));
	tokens.put("DURATION",		Integer.valueOf(Parser.DURATION));
	tokens.put("DYNAMIC",		Integer.valueOf(Parser.DYNAMIC));
	tokens.put("EDIT",		Integer.valueOf(Parser.EDIT));
	tokens.put("EMBEDDED",		Integer.valueOf(Parser.EMBEDDED));
	tokens.put("ENABLE",		Integer.valueOf(Parser.ENABLE));
	tokens.put("ENABLED",		Integer.valueOf(Parser.ENABLED));
	tokens.put("ENDTIME",		Integer.valueOf(Parser.ENDTIME));
	tokens.put("ENVIRONMENT",	Integer.valueOf(Parser.ENVIRONMENT));
	tokens.put("ENVIRONMENTS",	Integer.valueOf(Parser.ENVIRONMENT));
	tokens.put("ERRLOG",		Integer.valueOf(Parser.ERRLOG));
	tokens.put("ERRLOGFILE",	Integer.valueOf(Parser.ERRLOG));
	tokens.put("ERROR",		Integer.valueOf(Parser.ERROR_TOKEN));
	tokens.put("EQUIVALENT",	Integer.valueOf(Parser.EQUIVALENT));
	tokens.put("EVENT",		Integer.valueOf(Parser.EVENT));
	tokens.put("EVENTS",		Integer.valueOf(Parser.EVENT));
	tokens.put("EXECUTE",		Integer.valueOf(Parser.EXECUTE));
	tokens.put("EXIT",		Integer.valueOf(Parser.DISCONNECT));
	tokens.put("EXISTING",		Integer.valueOf(Parser.EXISTING));
	tokens.put("EXPAND",		Integer.valueOf(Parser.EXPAND));
	tokens.put("EXPIRED",		Integer.valueOf(Parser.EXPIRED));
	tokens.put("EXPORT",		Integer.valueOf(Parser.EXPORT));
	tokens.put("EXPR",		Integer.valueOf(Parser.EXPR));
	tokens.put("EXTERNAL",		Integer.valueOf(Parser.EXTERNAL));
	tokens.put("FACTOR",		Integer.valueOf(Parser.FACTOR));
	tokens.put("FAILURE",		Integer.valueOf(Parser.FAILURE));
	tokens.put("FATAL",		Integer.valueOf(Parser.FATAL));
	tokens.put("FILTER",		Integer.valueOf(Parser.FILTER));
	tokens.put("FINAL",		Integer.valueOf(Parser.FINAL));
	tokens.put("FINISH",		Integer.valueOf(Parser.FINISH));
	tokens.put("FINISHED",		Integer.valueOf(Parser.FINISHED));
	tokens.put("FOLDER",		Integer.valueOf(Parser.FOLDER));
	tokens.put("FOLDERS",		Integer.valueOf(Parser.FOLDER));
	tokens.put("FOOTPRINT",		Integer.valueOf(Parser.FOOTPRINT));
	tokens.put("FOOTPRINTS",	Integer.valueOf(Parser.FOOTPRINT));
	tokens.put("FOR",		Integer.valueOf(Parser.FOR));
	tokens.put("FORCE",		Integer.valueOf(Parser.FORCE));
	tokens.put("FREEPCT",		Integer.valueOf(Parser.FREEPCT));
	tokens.put("FROM",		Integer.valueOf(Parser.FROM));
	tokens.put("FUTURE",		Integer.valueOf(Parser.FUTURE));
	tokens.put("GET",		Integer.valueOf(Parser.GET));
	tokens.put("GLOBAL",		Integer.valueOf(Parser.GLOBAL));
	tokens.put("GRANT",		Integer.valueOf(Parser.GRANT));
	tokens.put("GRANTS",		Integer.valueOf(Parser.GRANT));
	tokens.put("GROUP",		Integer.valueOf(Parser.GROUP));
	tokens.put("GROUPS",		Integer.valueOf(Parser.GROUP));
	tokens.put("HEADER",		Integer.valueOf(Parser.HEADER));
	tokens.put("HISTORY",		Integer.valueOf(Parser.HISTORY));
	tokens.put("HOUR",		Integer.valueOf(Parser.HOUR));
	tokens.put("HOURS",		Integer.valueOf(Parser.HOUR));
	tokens.put("HORIZON",		Integer.valueOf(Parser.HORIZON));
	tokens.put("IDENTIFIED",	Integer.valueOf(Parser.IDENTIFIED));
	tokens.put("IGNORE",		Integer.valueOf(Parser.IGNORE));
	tokens.put("IMMEDIATE",		Integer.valueOf(Parser.IMMEDIATE));
	tokens.put("IMPORT",		Integer.valueOf(Parser.IMPORT));
	tokens.put("IN",		Integer.valueOf(Parser.IN));
	tokens.put("INACTIVE",		Integer.valueOf(Parser.INACTIVE));
	tokens.put("INFINIT",		Integer.valueOf(Parser.INFINITE));
	tokens.put("INFINITE",		Integer.valueOf(Parser.INFINITE));
	tokens.put("INHERIT",		Integer.valueOf(Parser.INHERIT));
	tokens.put("INFO",		Integer.valueOf(Parser.INFO));
	tokens.put("INSTANCE",		Integer.valueOf(Parser.INSTANCE));
	tokens.put("INSTANCES",		Integer.valueOf(Parser.INSTANCE));
	tokens.put("INTERNAL",		Integer.valueOf(Parser.INTERNAL));
	tokens.put("INTERVAL",		Integer.valueOf(Parser.INTERVAL));
	tokens.put("INTERVALS",		Integer.valueOf(Parser.INTERVAL));
	tokens.put("INVERSE",		Integer.valueOf(Parser.INVERSE));
	tokens.put("IS",		Integer.valueOf(Parser.IS));
	tokens.put("ISX",		Integer.valueOf(Parser.ISX));
	tokens.put("IX",		Integer.valueOf(Parser.IX));
	tokens.put("JOB",		Integer.valueOf(Parser.JOB));
	tokens.put("JOB_FINAL",		Integer.valueOf(Parser.JOB_FINAL));
	tokens.put("JOBS",		Integer.valueOf(Parser.JOB));
	tokens.put("JSON",		Integer.valueOf(Parser.JSON));
	tokens.put("KEEP",		Integer.valueOf(Parser.KEEP));
	tokens.put("KILL",		Integer.valueOf(Parser.KILL));
	tokens.put("KILLED",		Integer.valueOf(Parser.KILLED));
	tokens.put("LANGUAGE",		Integer.valueOf(Parser.LANGUAGE));
	tokens.put("LAST",		Integer.valueOf(Parser.LAST));
	tokens.put("LEADING",		Integer.valueOf(Parser.LEADING));
	tokens.put("LEVEL",		Integer.valueOf(Parser.LEVEL));
	tokens.put("LIBERAL",		Integer.valueOf(Parser.LIBERAL));
	tokens.put("LIKE",		Integer.valueOf(Parser.LIKE));
	tokens.put("LIMIT",		Integer.valueOf(Parser.LIMIT));
	tokens.put("LINE",		Integer.valueOf(Parser.LINE));
	tokens.put("LINK",		Integer.valueOf(Parser.LINK));
	tokens.put("LIST",		Integer.valueOf(Parser.LIST));
	tokens.put("LOCAL",		Integer.valueOf(Parser.LOCAL));
	tokens.put("LOCK",		Integer.valueOf(Parser.LOCK));
	tokens.put("LOCKS",		Integer.valueOf(Parser.LOCK));
	tokens.put("LOCKMODE",		Integer.valueOf(Parser.LOCKMODE));
	tokens.put("LOGFILE",		Integer.valueOf(Parser.LOGFILE));
	tokens.put("LOOPS",		Integer.valueOf(Parser.LOOPS));
	tokens.put("MAIN",		Integer.valueOf(Parser.MAIN));
	tokens.put("MANAGE",		Integer.valueOf(Parser.MANAGE));
	tokens.put("MANAGED",		Integer.valueOf(Parser.MANAGED));
	tokens.put("MAP",		Integer.valueOf(Parser.MAP));
	tokens.put("MAPPING",		Integer.valueOf(Parser.MAPPING));
	tokens.put("MAPPINGS",		Integer.valueOf(Parser.MAPPING));
	tokens.put("MAPS",		Integer.valueOf(Parser.MAPS));
	tokens.put("MASTER",		Integer.valueOf(Parser.MASTER));
	tokens.put("MASTER_ID",		Integer.valueOf(Parser.MASTER_ID));
	tokens.put("MAX",		Integer.valueOf(Parser.MAX));
	tokens.put("MAXPCT",		Integer.valueOf(Parser.MAXPCT));
	tokens.put("MERGE",		Integer.valueOf(Parser.MERGE));
	tokens.put("MERGED",		Integer.valueOf(Parser.MERGED));
	tokens.put("METHOD",		Integer.valueOf(Parser.METHOD));
	tokens.put("MILESTONE",		Integer.valueOf(Parser.MILESTONE));
	tokens.put("MILESTONES",	Integer.valueOf(Parser.MILESTONE));
	tokens.put("MIN",		Integer.valueOf(Parser.MIN));
	tokens.put("MINPCT",		Integer.valueOf(Parser.MINPCT));
	tokens.put("MINUTE",		Integer.valueOf(Parser.MINUTE));
	tokens.put("MINUTES",		Integer.valueOf(Parser.MINUTE));
	tokens.put("MODE",		Integer.valueOf(Parser.MODE));
	tokens.put("MONITOR",		Integer.valueOf(Parser.MONITOR));
	tokens.put("MONTH",		Integer.valueOf(Parser.MONTH));
	tokens.put("MONTHS",		Integer.valueOf(Parser.MONTH));
	tokens.put("MOVE",		Integer.valueOf(Parser.MOVE));
	tokens.put("MULTICOMMAND",	Integer.valueOf(Parser.MULTICOMMAND));
	tokens.put("MULTIPLIER",	Integer.valueOf(Parser.MULTIPLIER));
	tokens.put("N",			Integer.valueOf(Parser.N));
	tokens.put("NAME",		Integer.valueOf(Parser.NAME));
	tokens.put("NICEVALUE",		Integer.valueOf(Parser.NICEVALUE));
	tokens.put("NO",		Integer.valueOf(Parser.NO));
	tokens.put("NODE",		Integer.valueOf(Parser.NODE));
	tokens.put("NODES",		Integer.valueOf(Parser.NODE));
	tokens.put("NOINVERSE",		Integer.valueOf(Parser.NOINVERSE));
	tokens.put("NOKEEP",		Integer.valueOf(Parser.NOKEEP));
	tokens.put("NOMASTER",		Integer.valueOf(Parser.NOMASTER));
	tokens.put("NOMERGE",		Integer.valueOf(Parser.NOMERGE));
	tokens.put("NOMINALPCT",	Integer.valueOf(Parser.NOMINALPCT));
	tokens.put("NONE",		Integer.valueOf(Parser.NONE));
	tokens.put("NORESUME",		Integer.valueOf(Parser.NORESUME));
	tokens.put("NOSTICKY",		Integer.valueOf(Parser.NOSTICKY));
	tokens.put("NOSUSPEND",		Integer.valueOf(Parser.NOSUSPEND));
	tokens.put("NOT",		Integer.valueOf(Parser.NOT));
	tokens.put("NOTRACE",		Integer.valueOf(Parser.NOTRACE));
	tokens.put("NOTRUNC",		Integer.valueOf(Parser.NOTRUNC));
	tokens.put("NOWARN",		Integer.valueOf(Parser.NOWARN));
	tokens.put("OBJECT",		Integer.valueOf(Parser.OBJECT));
	tokens.put("OF",		Integer.valueOf(Parser.OF));
	tokens.put("OFFLINE",		Integer.valueOf(Parser.OFFLINE));
	tokens.put("ON",		Integer.valueOf(Parser.ON));
	tokens.put("ONLINE",		Integer.valueOf(Parser.ONLINE));
	tokens.put("ONLY",		Integer.valueOf(Parser.ONLY));
	tokens.put("OPERATE",		Integer.valueOf(Parser.OPERATE));
	tokens.put("OR",		Integer.valueOf(Parser.OR));
	tokens.put("OWNER",		Integer.valueOf(Parser.OWNER));
	tokens.put("PARENT",		Integer.valueOf(Parser.PARENT));
	tokens.put("PARAMETER",		Integer.valueOf(Parser.PARAMETERS));
	tokens.put("PARAMETERS",	Integer.valueOf(Parser.PARAMETERS));
	tokens.put("PASSWORD",		Integer.valueOf(Parser.PASSWORD));
	tokens.put("PATH",		Integer.valueOf(Parser.PATH));
	tokens.put("PENDING",		Integer.valueOf(Parser.PENDING));
	tokens.put("PERL",		Integer.valueOf(Parser.PERL));
	tokens.put("PID",		Integer.valueOf(Parser.PID));
	tokens.put("PLAIN",		Integer.valueOf(Parser.PLAIN));
	tokens.put("POOL",		Integer.valueOf(Parser.POOL));
	tokens.put("PRIORITY",		Integer.valueOf(Parser.PRIORITY));
	tokens.put("PROFILE",		Integer.valueOf(Parser.PROFILE));
	tokens.put("PROFILES",		Integer.valueOf(Parser.PROFILE));
	tokens.put("PROTOCOL",		Integer.valueOf(Parser.PROTOCOL));
	tokens.put("PUBLIC",		Integer.valueOf(Parser.PUBLIC));
	tokens.put("PYTHON",		Integer.valueOf(Parser.PYTHON));
	tokens.put("QUIT",		Integer.valueOf(Parser.DISCONNECT));
	tokens.put("QUOTED",		Integer.valueOf(Parser.QUOTED));
	tokens.put("RAW",		Integer.valueOf(Parser.RAW));
	tokens.put("RAWPASSWORD",	Integer.valueOf(Parser.RAWPASSWORD));
	tokens.put("REACHABLE",		Integer.valueOf(Parser.REACHABLE));
	tokens.put("READ",		Integer.valueOf(Parser.READ));
	tokens.put("REASSURE",		Integer.valueOf(Parser.REASSURE));
	tokens.put("RECREATE",		Integer.valueOf(Parser.RECREATE));
	tokens.put("RECURSIVE",		Integer.valueOf(Parser.RECURSIVE));
	tokens.put("REFERENCE",		Integer.valueOf(Parser.REFERENCE));
	tokens.put("REGISTER",		Integer.valueOf(Parser.REGISTER));
	tokens.put("REJECT",		Integer.valueOf(Parser.REJECT));
	tokens.put("RENAME",		Integer.valueOf(Parser.RENAME));
	tokens.put("RENICE",		Integer.valueOf(Parser.RENICE));
	tokens.put("REQUIRED",		Integer.valueOf(Parser.REQUIRED));
	tokens.put("RERUN",		Integer.valueOf(Parser.RERUN));
	tokens.put("RESOLVE",		Integer.valueOf(Parser.RESOLVE));
	tokens.put("RESOURCE",		Integer.valueOf(Parser.RESOURCE));
	tokens.put("RESOURCES",		Integer.valueOf(Parser.RESOURCE));
	tokens.put("RESTARTABLE",	Integer.valueOf(Parser.RESTARTABLE));
	tokens.put("RESTRICT",		Integer.valueOf(Parser.RESTRICT));
	tokens.put("RESULT",		Integer.valueOf(Parser.RESULT));
	tokens.put("RESUME",		Integer.valueOf(Parser.RESUME));
	tokens.put("REVOKE",		Integer.valueOf(Parser.REVOKE));
	tokens.put("REVIEW",		Integer.valueOf(Parser.REVIEW));
	tokens.put("ROLLBACK",		Integer.valueOf(Parser.ROLLBACK));
	tokens.put("ROOT",		Integer.valueOf(Parser.ROOT));
	tokens.put("RUN",		Integer.valueOf(Parser.RUN));
	tokens.put("RUNNABLE",		Integer.valueOf(Parser.RUNNABLE));
	tokens.put("RUNNING",		Integer.valueOf(Parser.RUNNING));
	tokens.put("RUNTIME",		Integer.valueOf(Parser.RUNTIME));
	tokens.put("S",			Integer.valueOf(Parser.S));
	tokens.put("SALT",		Integer.valueOf(Parser.SALT));
	tokens.put("SC",		Integer.valueOf(Parser.SC));
	tokens.put("SCHEDULE",		Integer.valueOf(Parser.SCHEDULE));
	tokens.put("SCHEDULED",		Integer.valueOf(Parser.SCHEDULED));
	tokens.put("SCHEDULES",		Integer.valueOf(Parser.SCHEDULE));
	tokens.put("SCOPE",		Integer.valueOf(Parser.SCOPE));
	tokens.put("SCOPES",		Integer.valueOf(Parser.SCOPE));
	tokens.put("SELECTION",		Integer.valueOf(Parser.SELECTION));
	tokens.put("SERIAL",		Integer.valueOf(Parser.SERIAL));
	tokens.put("SERVER",		Integer.valueOf(Parser.SERVER));
	tokens.put("SERVERS",		Integer.valueOf(Parser.SERVER));
	tokens.put("SESSION",		Integer.valueOf(Parser.SESSION));
	tokens.put("SESSIONS",		Integer.valueOf(Parser.SESSION));
	tokens.put("SET",		Integer.valueOf(Parser.SET));
	tokens.put("SHOW",		Integer.valueOf(Parser.SHOW));
	tokens.put("SHUTDOWN",		Integer.valueOf(Parser.SHUTDOWN));
	tokens.put("SINGLE",		Integer.valueOf(Parser.SINGLE));
	tokens.put("SORT",		Integer.valueOf(Parser.SORT));
	tokens.put("SQLSELECT",		Integer.valueOf(Parser.SQLSELECT));
	tokens.put("SSL",		Integer.valueOf(Parser.SSL));
	tokens.put("STARTED",		Integer.valueOf(Parser.STARTED));
	tokens.put("STARTING",		Integer.valueOf(Parser.STARTING));
	tokens.put("STARTTIME",		Integer.valueOf(Parser.STARTTIME));
	tokens.put("STATE",		Integer.valueOf(Parser.STATUS));
	tokens.put("STATES",		Integer.valueOf(Parser.STATUS));
	tokens.put("STATIC",		Integer.valueOf(Parser.STATIC));
	tokens.put("STATUS",		Integer.valueOf(Parser.STATUS));
	tokens.put("STICKY",		Integer.valueOf(Parser.STICKY));
	tokens.put("STRICT",		Integer.valueOf(Parser.STRICT));
	tokens.put("STOP",		Integer.valueOf(Parser.STOP));
	tokens.put("SUBMIT",		Integer.valueOf(Parser.SUBMIT));
	tokens.put("SUBMITCOUNT",	Integer.valueOf(Parser.SUBMITCOUNT));
	tokens.put("SUBMITTAG",		Integer.valueOf(Parser.SUBMITTAG));
	tokens.put("SUBMITTED",		Integer.valueOf(Parser.SUBMITTED));
	tokens.put("SUM",		Integer.valueOf(Parser.SUM));
	tokens.put("SUSPEND",		Integer.valueOf(Parser.SUSPEND));
	tokens.put("SUSPENDED",		Integer.valueOf(Parser.SUSPENDED));
	tokens.put("SX",		Integer.valueOf(Parser.SX));
	tokens.put("SYNCHRONIZING",	Integer.valueOf(Parser.SYNCHRONIZING));
	tokens.put("SYNCTIME",		Integer.valueOf(Parser.SYNCTIME));
	tokens.put("SYSTEM",		Integer.valueOf(Parser.SYSTEM));
	tokens.put("TAG",		Integer.valueOf(Parser.TAG));
	tokens.put("TERMINATED",	Integer.valueOf(Parser.TERMINATED));
	tokens.put("TEST",		Integer.valueOf(Parser.TEST));
	tokens.put("TEXT",		Integer.valueOf(Parser.TEXT));
	tokens.put("TIME",		Integer.valueOf(Parser.TIME));
	tokens.put("TIMEOUT",		Integer.valueOf(Parser.TIMEOUT));
	tokens.put("TIMESTAMP",		Integer.valueOf(Parser.TIMESTAMP));
	tokens.put("TO",		Integer.valueOf(Parser.TO));
	tokens.put("TOKEN",		Integer.valueOf(Parser.TOKEN));
	tokens.put("TOUCH",		Integer.valueOf(Parser.TOUCH));
	tokens.put("TRACE",		Integer.valueOf(Parser.TRACE));
	tokens.put("TRANSLATION",	Integer.valueOf(Parser.TRANSLATION));
	tokens.put("TRANSLATIONS",	Integer.valueOf(Parser.TRANSLATION));
	tokens.put("TREE",		Integer.valueOf(Parser.TREE));
	tokens.put("TRIGGER",		Integer.valueOf(Parser.TRIGGER));
	tokens.put("TRUNC",		Integer.valueOf(Parser.TRUNC));
	tokens.put("TYPE",		Integer.valueOf(Parser.TYPE));
	tokens.put("TYPES",		Integer.valueOf(Parser.TYPE));
	tokens.put("UNREACHABLE",	Integer.valueOf(Parser.UNREACHABLE));
	tokens.put("UNRESOLVED",	Integer.valueOf(Parser.UNRESOLVED));
	tokens.put("URL",		Integer.valueOf(Parser.URL));
	tokens.put("UPDATE",		Integer.valueOf(Parser.UPDATE));
	tokens.put("USAGE",		Integer.valueOf(Parser.USAGE));
	tokens.put("USE",		Integer.valueOf(Parser.USE));
	tokens.put("USER",		Integer.valueOf(Parser.USER));
	tokens.put("USERS",		Integer.valueOf(Parser.USER));
	tokens.put("VALUE",		Integer.valueOf(Parser.VALUE));
	tokens.put("VERSION",		Integer.valueOf(Parser.VERSION));
	tokens.put("VIEW",		Integer.valueOf(Parser.VIEW));
	tokens.put("WARN",		Integer.valueOf(Parser.WARN));
	tokens.put("WARNING",		Integer.valueOf(Parser.WARNING));
	tokens.put("WATCH",		Integer.valueOf(Parser.WATCH));
	tokens.put("WATCHER",		Integer.valueOf(Parser.WATCHER));
	tokens.put("WEEK",		Integer.valueOf(Parser.WEEK));
	tokens.put("WEEKS",		Integer.valueOf(Parser.WEEK));
	tokens.put("WITH",		Integer.valueOf(Parser.WITH));
	tokens.put("WORKDIR",		Integer.valueOf(Parser.WORKDIR));
	tokens.put("X",			Integer.valueOf(Parser.X));
	tokens.put("XML",		Integer.valueOf(Parser.XML));
	tokens.put("YEAR",		Integer.valueOf(Parser.YEAR));
	tokens.put("YEARS",		Integer.valueOf(Parser.YEAR));
	tokens.put("ZERO",		Integer.valueOf(Parser.ZERO));
	tokens.put("ZONE",		Integer.valueOf(Parser.ZONE));
	stmt = new StringBuffer();
/*
*/
%init}

%{
private static boolean debug = false;

public int yyline()
{
	return yyline + 1;
}

private int token;
private Token t;
private Object value;
private HashMap tokens;
private StringBuffer stmt;
private StringBuffer sel_stmt;
private ConnectionEnvironment env;
private final SimpleDateFormat df = (SimpleDateFormat) SystemEnvironment.staticSystemDateFormat.clone();
private int selbrctr = 0;
private boolean inMultiCmd = false;

/** move to next token
    @return false if positioned beyond tokens (EOF)
    @throws IOException on input error
*/
public boolean advance() throws java.io.IOException
{
	token = yylex();
	return (token != YYEOF);
}

/** classifies current token
    should not be called if advance() returned false
    @return current %token or single character
*/
public int token()
{
	return token;
}

public Token getToken()
{
	return t;
}

public void proto_input(String s)
{
	if (debug) {
		System.err.println("Found Token ->" + s + "<-");
	}
	if (env.firstToken == null) {
		env.firstToken = s;
		env.setState(ConnectionEnvironment.PARSING);
	}
	stmt.append(s);
}

public void unproto_input(String s)
{
	String tmp;
	
	int pos = stmt.lastIndexOf(s);
	if(pos > 0) {
		tmp = stmt.substring(pos + s.length());
		tmp = stmt.substring(0,pos) + "**********" + tmp;		
		stmt = new StringBuffer(tmp);
	}	
}

public void tell_input()
{
	if (inMultiCmd) return;
	int severity;
	if(env.trace())	severity = SDMSThread.SEVERITY_INFO;
	else 		severity = SDMSThread.SEVERITY_MESSAGE;
	SDMSThread.doTrace(env, stmt.toString(), severity);
	env.actstmt = new String(stmt);
	stmt.delete(0, stmt.length());
}

public void setEnv(ConnectionEnvironment p_env)
{
	env = p_env;
}

public boolean inStatement()
{
	if (env == null) return false;
	UserConnection c = (UserConnection) env.getMe();
	return c.inStatement();
}

/** associated with current token
    should not be called after advance() returned false.
    @return value for token();
*/
public Object value() 
{
	return t;
}
%}

alpha	=	[a-zA-Z_@#]
alnum	=	[a-zA-Z_0-9@#]
dec	=	[0-9]
sign	=	[-+]?
exp	=	([eE]{sign}{dec}+)
fp	=	({dec}+"."{dec}*{exp}?|"."{dec}+{exp}?|{dec}+{exp})
ws	=	[ \t\n\r\b\015\u2028\u2029\u000B\u000C\u0085\u00A0]
nws_nsc	=	[^ \t\n\r\b\015\0\u2028\u2029\u000B\u000C\u0085\u00A0;'()]
uscore  =	(_|[ \n\t\r]*)
brackets =	[()]
delimiter =	[,.=+-]
nulbyte =	\0
cmpop	=	">"|"<"|">="|"<="|"=="|"<>"|"!="|"=~"|"!~"
active =	[Aa][Cc][Tt][Ii][Vv][Ee]
after =		[Aa][Ff][Tt][Ee][Rr]
all =		[Aa][Ll][Ll]
amount =	[Aa][Mm][Oo][Uu][Nn][Tt]
backlog =	[Bb][Aa][Cc][Kk][Ll][Oo][Gg]
before =	[Bb][Ee][Ff][Oo][Rr][Ee]
begin =		[Bb][Ee][Gg][Ii][Nn]
broken =	[Bb][Rr][Oo][Kk][Ee][Nn]
change =	[Cc][Hh][Aa][Nn][Gg][Ee]
child =		[Cc][Hh][Ii][Ll][Dd]
code =		[Cc][Oo][Dd][Ee]
constant =	[Cc][Oo][Nn][Ss][Tt][Aa][Nn][Tt]
default =	[Dd][Ee][Ff][Aa][Uu][Ll][Tt]
defer	 =	[Dd][Ee][Ff][Ee][Rr]
definition =	[Dd][Ee][Ff][Ii][Nn][Ii][Tt][Ii][Oo][Nn]([Ss])?
dependencx =	[Dd][Ee][Pp][Ee][Nn][Dd][Ee][Nn][Cc][Yy]
dependencies =	[Dd][Ee][Pp][Ee][Nn][Dd][Ee][Nn][Cc][Ii][Ee][Ss]
end =		[Ee][Nn][Dd]
error =		[Ee][Rr][Rr][Oo][Rr]
event =		[Ee][Vv][Ee][Nn][Tt]([Ss])?
exec =		[Ee][Xx][Ee][Cc]
exit =		[Ee][Xx][Ii][Tt]
ext =		[Ee][Xx][Tt]
fatal =		[Ff][Aa][Tt][Aa][Ll]
final =		[Ff][Ii][Nn][Aa][Ll]
finish =	[Ff][Ii][Nn][Ii][Ss][Hh]
finished =	[Ff][Ii][Nn][Ii][Ss][Hh][Ee][Dd]
free =		[Ff][Rr][Ee][Ee]
get =		[Gg][Ee][Tt]
global =	[Gg][Ll][Oo][Bb][Aa][Ll]
handling =	[Hh][Aa][Nn][Dd][Ll][Ii][Nn][Gg]
hierarchy =	[Hh][Ii][Ee][Rr][Aa][Rr][Cc][Hh][Yy]
ignore =	[Ii][Gg][Nn][Oo][Rr][Ee]
immediate =	[Ii][Mm][Mm][Ee][Dd][Ii][Aa][Tt][Ee]
initial =	[Ii][Nn][Ii][Tt][Ii][Aa][Ll]
job =		[Jj][Oo][Bb]([Ss])?
keep =		[Kk][Ee][Ee][Pp]
kill =		[Kk][Ii][Ll][Ll]
limit =		[Ll][Ii][Mm][Ii][Tt]
local =		[Ll][Oo][Cc][Aa][Ll]
manage =	[Mm][Aa][Nn][Aa][Gg]([Ee])?
mapping =	[Mm][Aa][Pp][Pp][Ii][Nn][Gg]([Ss])?
merge =		[Mm][Ee][Rr][Gg][Ee]
mode =		[Mm][Oo][Dd][Ee]
multicommand =	[Mm][Uu][Ll][Tt][Ii][Cc][Oo][Mm][Mm][Aa][Nn][Dd]
named =		[Nn][Aa][Mm][Ee][Dd]
next =		[Nn][Ee][Xx][Tt]
nice =		[Nn][Ii][Cc][Ee]
non =		[Nn][Oo][Nn]
pid =		[Pp][Ii][Dd]
profile =	[Pp][Rr][Oo][Ff][Ii][Ll][Ee]([Ss])?
program =	[Pp][Rr][Oo][Gg][Rr][Aa][Mm]
rerun =		[Rr][Ee][Rr][Uu][Nn]
resource =	[Rr][Ee][Ss][Oo][Uu][Rr][Cc][Ee]
resources =	[Rr][Ee][Ss][Oo][Uu][Rr][Cc][Ee][Ss]
requestable =	[Rr][Ee][Qq][Uu][Ee][Ss][Tt][Aa][Bb][Ll][Ee]
run =		[Rr][Uu][Nn]
scheduled =	[Ss][Cc][Hh][Ee][Dd][Uu][Ll][Ee][Dd]
select =	[Ss][Ee][Ll][Ee][Cc][Tt]
server =	[Ss][Ee][Rr][Vv][Ee][Rr]
status1 =	[Ss][Tt][Aa][Tt][Ee]([Ss])?
status2 =	[Ss][Tt][Aa][Tt][Uu][Ss]
state =		{status1}|{status2}
submitting =	[Ss][Uu][Bb][Mm][Ii][Tt][Tt][Ii][Nn][Gg]
suspend =	[Ss][Uu][Ss][Pp][Ee][Nn][Dd]
synchronize =	[Ss][Yy][Nn][Cc][Hh][Rr][Oo][Nn][Ii][Zz][Ee]
template =	[Tt][Ee][Mm][Pp][Ll][Aa][Tt][Ee]
text =		[Tt][Ee][Xx][Tt]
to =		[Tt][Oo]
translation =	[Tt][Rr][Aa][Nn][Ss][Ll][Aa][Tt][Ii][Oo][Nn]([Ss])?
user =		[Uu][Ss][Ee][Rr]
until =		[Uu][Nn][Tt][Ii][Ll]
wait =		[Ww][Aa][Ii][Tt]
with =		[Ww][Ii][Tt][Hh]

resourcex =		{resource}|{resources}
after_final =		{after}{uscore}{final}
all_final =		{all}{uscore}{final}
backlog_handling =	{backlog}{uscore}{handling}
before_final =		{before}{uscore}{final}
bmulticmd =		{begin}{uscore}{multicommand}
broken_active =		{broken}{uscore}{active}
broken_finished =	{broken}{uscore}{finished}
change_state =		{change}{uscore}{state}
default_mapping =	{default}{uscore}{mapping}
defer_ignore =		{defer}{uscore}{ignore}
dependency =		{dependencx}|{dependencies}
dependency_definition = {dependency}{uscore}{definition}
dependency_hierarchy = 	{dependency}{uscore}{hierarchy}
dependency_mode =	{dependency}{uscore}{mode}
dependency_wait =	{dependency}{uscore}{wait}
emulticmd =		{end}{uscore}{multicommand}
error_text =		{error}{uscore}{text}
exec_pid =		{exec}{uscore}{pid}
exit_code =		{exit}{uscore}{code}
exit_state =		{exit}{uscore}{state}
exit_state_mapping =	{exit}{uscore}{state}{uscore}{mapping}
exit_state_definition =	{exit}{uscore}{state}{uscore}{definition}
exit_state_profile =	{exit}{uscore}{state}{uscore}{profile}
exit_state_translation =	{exit}{uscore}{state}{uscore}{translation}
ext_pid =		{ext}{uscore}{pid}
finish_child =		{finish}{uscore}{child}
free_amount =		{free}{uscore}{amount}
get_next_job =		{get}{uscore}{next}{uscore}{job}
ignore_dependency =	{ignore}{uscore}{dependency}
immediate_local =	{immediate}{uscore}{local}
immediate_merge =	{immediate}{uscore}{merge}
initial_state =		{initial}{uscore}{state}
job_definition =	{job}{uscore}{definition}
job_definition_hierarchy =	{job}{uscore}{definition}{uscore}{hierarchy}
job_final =		{job}{uscore}{final}
job_server =		{job}{uscore}{server}
job_state =		{job}{uscore}{state}
keep_final =		{keep}{uscore}{final}
kill_program =		{kill}{uscore}{program}
local_constant =	{local}{uscore}{constant}
manage_select =		{manage}{uscore}{select}
merge_mode =		{merge}{uscore}{mode}
merge_global =		{merge}{uscore}{global}
merge_local =		{merge}{uscore}{local}
named_resource =	{named}{uscore}{resourcex}
nice_profile =		{nice}{uscore}{profile}
non_fatal =		{non}{uscore}{fatal}
requestable_amount =		{requestable}{uscore}{amount}
resource_state =	{resource}{uscore}{state}
resource_state_definition =	{resource}{uscore}{state}{uscore}{definition}
resource_state_mapping =	{resource}{uscore}{state}{uscore}{mapping}
resource_state_profile =	{resource}{uscore}{state}{uscore}{profile}
resource_template =	{resource}{uscore}{template}
resource_wait =		{resource}{uscore}{wait}
run_program =		{run}{uscore}{program}
rerun_program =		{rerun}{uscore}{program}
scheduled_event =	{scheduled}{uscore}{event}
state_profile =		{state}{uscore}{profile}
status_mapping =	{state}{uscore}{mapping}
suspend_limit =		{suspend}{uscore}{limit}
submitting_user =	{submitting}{uscore}{user}
synchronize_wait =	{synchronize}{uscore}{wait}
to_kill =		{to}{uscore}{kill}
until_final =		{until}{uscore}{final}
until_finished =	{until}{uscore}{finished}

%state	STRING COMMENT SELECT SELECTSTR
%%

<YYINITIAL>"//".*			{ /* do nothing */ break; }
<YYINITIAL>--.*				{ /* do nothing */ break; }
<YYINITIAL>{dec}+			{ proto_input(yytext());
					  try {
						value = Long.valueOf(yytext());
						t = new Token(Parser.INTEGER, yytext(), value);
					  } catch (NumberFormatException nfe) {
						value = SDMSConstants.lZERO;
						t = new Token(Parser.NAN, yytext(), value);
						return Parser.NAN;
					  }
					  return Parser.INTEGER;
					}
<YYINITIAL>{fp}				{ proto_input(yytext());
					  try {
						value = Float.valueOf(yytext());
						t = new Token(Parser.FLOAT, yytext(), value);
					  } catch (NumberFormatException nfe) {
						value = SDMSConstants.fZERO;	// as soon as we really need floats (we don't at the moment)
						t = new Token(Parser.NAN, yytext(), value);
						return Parser.NAN;	// this might be a problem
					  }
					  return Parser.FLOAT;
					}
<YYINITIAL>{nulbyte}			{ tell_input(); value = ""; t = new Token(Parser.FORCED_EOC, (String)  value);		return Parser.FORCED_EOC; }
<YYINITIAL>{cmpop}			{ proto_input(yytext()); value = yytext(); t = new Token(Parser.CMPOP, yytext());	return Parser.CMPOP; }
<YYINITIAL>{ws}				{ if(stmt.length() != 0) proto_input(yytext()); /* do nothing */ break; }
<YYINITIAL>{after_final}		{ proto_input(yytext()); t = new Token(Parser.AFTER_FINAL, yytext());			return Parser.AFTER_FINAL; }
<YYINITIAL>{all_final}			{ proto_input(yytext()); t = new Token(Parser.ALL_FINAL, yytext());			return Parser.ALL_FINAL; }
<YYINITIAL>{backlog_handling}		{ proto_input(yytext()); t = new Token(Parser.BACKLOG_HANDLING, yytext());		return Parser.BACKLOG_HANDLING; }
<YYINITIAL>{before_final}		{ proto_input(yytext()); t = new Token(Parser.BEFORE_FINAL, yytext());			return Parser.BEFORE_FINAL; }
<YYINITIAL>{bmulticmd}			{ proto_input(yytext()); t = new Token(Parser.BMULTICMD, yytext()); inMultiCmd = true;	return Parser.BMULTICMD; }
<YYINITIAL>{broken_active}		{ proto_input(yytext()); t = new Token(Parser.BROKEN_ACTIVE, yytext());			return Parser.BROKEN_ACTIVE; }
<YYINITIAL>{broken_finished}		{ proto_input(yytext()); t = new Token(Parser.BROKEN_FINISHED, yytext());		return Parser.BROKEN_FINISHED; }
<YYINITIAL>{change_state}		{ proto_input(yytext()); t = new Token(Parser.CHANGE_STATUS, yytext());			return Parser.CHANGE_STATUS; }
<YYINITIAL>{default_mapping}		{ proto_input(yytext()); t = new Token(Parser.DEFAULT_MAPPING, yytext());		return Parser.DEFAULT_MAPPING; }
<YYINITIAL>{defer_ignore}		{ proto_input(yytext()); t = new Token(Parser.DEFER_IGNORE, yytext());			return Parser.DEFER_IGNORE; }
<YYINITIAL>{dependency_definition}	{ proto_input(yytext()); t = new Token(Parser.DEPENDENCY_DEFINITION, yytext());		return Parser.DEPENDENCY_DEFINITION; }
<YYINITIAL>{dependency_hierarchy}	{ proto_input(yytext()); t = new Token(Parser.DEPENDENCY_HIERARCHY, yytext());		return Parser.DEPENDENCY_HIERARCHY; }
<YYINITIAL>{dependency_mode}		{ proto_input(yytext()); t = new Token(Parser.DEPENDENCY_MODE, yytext());		return Parser.DEPENDENCY_MODE; }
<YYINITIAL>{dependency_wait}		{ proto_input(yytext()); t = new Token(Parser.DEPENDENCY_WAIT, yytext());		return Parser.DEPENDENCY_WAIT; }
<YYINITIAL>{emulticmd}			{ proto_input(yytext()); t = new Token(Parser.EMULTICMD, yytext()); inMultiCmd = false;	return Parser.EMULTICMD; }
<YYINITIAL>{error_text}			{ proto_input(yytext()); t = new Token(Parser.ERROR_TEXT, yytext());			return Parser.ERROR_TEXT; }
<YYINITIAL>{exec_pid}			{ proto_input(yytext()); t = new Token(Parser.EXEC_PID, yytext());			return Parser.EXEC_PID; }
<YYINITIAL>{exit_code}			{ proto_input(yytext()); t = new Token(Parser.EXIT_CODE, yytext());			return Parser.EXIT_CODE; }
<YYINITIAL>{exit_state}			{ proto_input(yytext()); t = new Token(Parser.EXIT_STATUS, yytext());			return Parser.EXIT_STATUS; }
<YYINITIAL>{exit_state_definition}	{ proto_input(yytext()); t = new Token(Parser.EXIT_STATUS_DEFINITION, yytext());	return Parser.EXIT_STATUS_DEFINITION; }
<YYINITIAL>{exit_state_mapping}		{ proto_input(yytext()); t = new Token(Parser.EXIT_STATUS_MAPPING, yytext());		return Parser.EXIT_STATUS_MAPPING; }
<YYINITIAL>{exit_state_profile}		{ proto_input(yytext()); t = new Token(Parser.EXIT_STATUS_PROFILE, yytext());		return Parser.EXIT_STATUS_PROFILE; }
<YYINITIAL>{exit_state_translation}	{ proto_input(yytext()); t = new Token(Parser.EXIT_STATUS_TRANSLATION, yytext());	return Parser.EXIT_STATUS_TRANSLATION; }
<YYINITIAL>{ext_pid}			{ proto_input(yytext()); t = new Token(Parser.EXT_PID, yytext());			return Parser.EXT_PID; }
<YYINITIAL>{finish_child}		{ proto_input(yytext()); t = new Token(Parser.FINISH_CHILD, yytext());			return Parser.FINISH_CHILD; }
<YYINITIAL>{free_amount}		{ proto_input(yytext()); t = new Token(Parser.FREE_AMOUNT, yytext());			return Parser.FREE_AMOUNT; }
<YYINITIAL>{get_next_job}		{ proto_input(yytext()); t = new Token(Parser.GET_NEXT_JOB, yytext());			return Parser.GET_NEXT_JOB; }
<YYINITIAL>{ignore_dependency}		{ proto_input(yytext()); t = new Token(Parser.IGNORE_DEPENDENCY, yytext());		return Parser.IGNORE_DEPENDENCY; }
<YYINITIAL>{immediate_local}		{ proto_input(yytext()); t = new Token(Parser.IMMEDIATE_LOCAL, yytext());		return Parser.IMMEDIATE_LOCAL; }
<YYINITIAL>{immediate_merge}		{ proto_input(yytext()); t = new Token(Parser.IMMEDIATE_MERGE, yytext());		return Parser.IMMEDIATE_MERGE; }
<YYINITIAL>{initial_state}		{ proto_input(yytext()); t = new Token(Parser.INITIAL_STATUS, yytext());		return Parser.INITIAL_STATUS; }
<YYINITIAL>{job_definition}		{ proto_input(yytext()); t = new Token(Parser.JOB_DEFINITION, yytext());		return Parser.JOB_DEFINITION; }
<YYINITIAL>{job_definition_hierarchy}	{ proto_input(yytext()); t = new Token(Parser.JOB_DEFINITION_HIERARCHY, yytext());	return Parser.JOB_DEFINITION_HIERARCHY; }
<YYINITIAL>{job_final}			{ proto_input(yytext()); t = new Token(Parser.JOB_FINAL, yytext());			return Parser.JOB_FINAL; }
<YYINITIAL>{job_server}			{ proto_input(yytext()); t = new Token(Parser.JOB_SERVER, yytext());			return Parser.JOB_SERVER; }
<YYINITIAL>{job_state}			{ proto_input(yytext()); t = new Token(Parser.JOB_STATUS, yytext());			return Parser.JOB_STATUS; }
<YYINITIAL>{keep_final}			{ proto_input(yytext()); t = new Token(Parser.KEEP_FINAL, yytext());			return Parser.KEEP_FINAL; }
<YYINITIAL>{kill_program}		{ proto_input(yytext()); t = new Token(Parser.KILL_PROGRAM, yytext());			return Parser.KILL_PROGRAM; }
<YYINITIAL>{local_constant}		{ proto_input(yytext()); t = new Token(Parser.LOCAL_CONSTANT, yytext());		return Parser.LOCAL_CONSTANT; }
<YYINITIAL>{manage_select}		{ proto_input(yytext()); t = new Token(Parser.MANAGE_SELECT, yytext());			return Parser.MANAGE_SELECT; }
<YYINITIAL>{merge_global}		{ proto_input(yytext()); t = new Token(Parser.MERGE_GLOBAL, yytext());			return Parser.MERGE_GLOBAL; }
<YYINITIAL>{merge_local}		{ proto_input(yytext()); t = new Token(Parser.MERGE_LOCAL, yytext());			return Parser.MERGE_LOCAL; }
<YYINITIAL>{merge_mode}			{ proto_input(yytext()); t = new Token(Parser.MERGE_MODE, yytext());			return Parser.MERGE_MODE; }
<YYINITIAL>{named_resource}		{ proto_input(yytext()); t = new Token(Parser.NAMED_RESOURCE, yytext());		return Parser.NAMED_RESOURCE; }
<YYINITIAL>{nice_profile}		{ proto_input(yytext()); t = new Token(Parser.NICE_PROFILE, yytext());			return Parser.NICE_PROFILE; }
<YYINITIAL>{non_fatal}			{ proto_input(yytext()); t = new Token(Parser.NONFATAL, yytext());			return Parser.NONFATAL; }
<YYINITIAL>{requestable_amount}		{ proto_input(yytext()); t = new Token(Parser.REQUESTABLE_AMOUNT, yytext());		return Parser.REQUESTABLE_AMOUNT; }
<YYINITIAL>{rerun_program}		{ proto_input(yytext()); t = new Token(Parser.RERUN_PROGRAM, yytext());			return Parser.RERUN_PROGRAM; }
<YYINITIAL>{resource_state}		{ proto_input(yytext()); t = new Token(Parser.RESOURCE_STATUS, yytext());		return Parser.RESOURCE_STATUS; }
<YYINITIAL>{resource_state_definition}	{ proto_input(yytext()); t = new Token(Parser.RESOURCE_STATUS_DEFINITION, yytext());	return Parser.RESOURCE_STATUS_DEFINITION; }
<YYINITIAL>{resource_state_mapping}	{ proto_input(yytext()); t = new Token(Parser.RESOURCE_STATUS_MAPPING, yytext());	return Parser.RESOURCE_STATUS_MAPPING; }
<YYINITIAL>{resource_state_profile}	{ proto_input(yytext()); t = new Token(Parser.RESOURCE_STATUS_PROFILE, yytext());	return Parser.RESOURCE_STATUS_PROFILE; }
<YYINITIAL>{resource_template}		{ proto_input(yytext()); t = new Token(Parser.RESOURCE_TEMPLATE, yytext());		return Parser.RESOURCE_TEMPLATE; }
<YYINITIAL>{resource_wait}		{ proto_input(yytext()); t = new Token(Parser.RESOURCE_WAIT, yytext());			return Parser.RESOURCE_WAIT; }
<YYINITIAL>{run_program}		{ proto_input(yytext()); t = new Token(Parser.RUN_PROGRAM, yytext());			return Parser.RUN_PROGRAM; }
<YYINITIAL>{scheduled_event}		{ proto_input(yytext()); t = new Token(Parser.SCHEDULED_EVENT, yytext());		return Parser.SCHEDULED_EVENT; }
<YYINITIAL>{select}			{ proto_input(yytext());
					  if (inStatement()) {
						// we're in some statement where SELECT doesn't have a special meaning (it's not the start of a SELECT command)
						t = new Token(Parser.SELECT, yytext());
						return Parser.SELECT;
					  }
					  sel_stmt = new StringBuffer("SELECT ");
					  yybegin(SELECT);
					  selbrctr = 0;
					  break;
					}
<YYINITIAL>{state_profile}		{ proto_input(yytext()); t = new Token(Parser.STATUS_PROFILE, yytext());		return Parser.STATUS_PROFILE; }
<YYINITIAL>{status_mapping}		{ proto_input(yytext()); t = new Token(Parser.STATUS_MAPPING, yytext());		return Parser.STATUS_MAPPING; }
<YYINITIAL>{submitting_user}		{ proto_input(yytext()); t = new Token(Parser.SUBMITTING_USER, yytext());		return Parser.SUBMITTING_USER; }
<YYINITIAL>{suspend_limit}		{ proto_input(yytext()); t = new Token(Parser.SUSPEND_LIMIT, yytext());			return Parser.SUSPEND_LIMIT; }
<YYINITIAL>{synchronize_wait}		{ proto_input(yytext()); t = new Token(Parser.SYNCHRONIZE_WAIT, yytext());		return Parser.SYNCHRONIZE_WAIT; }
<YYINITIAL>{to_kill}			{ proto_input(yytext()); t = new Token(Parser.TO_KILL, yytext());			return Parser.TO_KILL; }
<YYINITIAL>{until_final}		{ proto_input(yytext()); t = new Token(Parser.UNTIL_FINAL, yytext());			return Parser.UNTIL_FINAL; }
<YYINITIAL>{until_finished}		{ proto_input(yytext()); t = new Token(Parser.UNTIL_FINISHED, yytext());		return Parser.UNTIL_FINISHED; }
<YYINITIAL>{alpha}{alnum}*		{
					  proto_input(yytext());
					  value = new String(yytext()).toUpperCase();
					  Integer i = (Integer) tokens.get(value);
					  if(i != null) {
						t = new Token(i, yytext(), value);
						return i.intValue();
					  }
					  t = new Token(Parser.IDENTIFIER, yytext(), value);
					  return Parser.IDENTIFIER;
					}
<YYINITIAL>\'				{ proto_input(yytext()); yybegin(STRING); value = new String(""); break; }
<YYINITIAL>"/*"				{ yybegin(COMMENT); break; }
<YYINITIAL>;				{ proto_input(yytext()); tell_input(); t = new Token(yytext().charAt(0), yytext());		return Parser.SECO; }
<YYINITIAL>\*				{ proto_input(yytext()); t = new Token(yytext().charAt(0), yytext());	return yytext().charAt(0); }
<YYINITIAL>{brackets}			{ proto_input(yytext()); t = new Token(yytext().charAt(0), yytext());	return yytext().charAt(0); }
<YYINITIAL>{delimiter}			{ proto_input(yytext()); t = new Token(yytext().charAt(0), yytext());	return yytext().charAt(0); }
<YYINITIAL>.				{ proto_input(yytext()); t = new Token(yytext().charAt(0), yytext());	return Parser.OTHER; }
<STRING>\'				{ proto_input(value.toString());
					  proto_input(yytext());
					  yybegin(YYINITIAL);
					  t = new Token(Parser.STRING, (String) value, value);
					  return Parser.STRING;
					}
<STRING>\\\'				{ value = ((String) value) + "'"; break; }
<STRING>\\\\				{ value = ((String) value) + "\\"; break; }
<STRING>\\				{ value = ((String) value) + "\\"; break; }
<STRING>[^\\\'\0]+			{ value = ((String) value) + new String(yytext()); break; }
<STRING>{nulbyte}			{ tell_input(); value = ""; yybegin(YYINITIAL); t = new Token(Parser.FORCED_EOC, (String) value); return Parser.FORCED_EOC; }
<COMMENT>"*/"				{ yybegin(YYINITIAL); break; }
<COMMENT>[^*\0]+			{ /* do nothing */ break; }
<COMMENT>\*				{ /* do nothing */ break; }
<COMMENT>{nulbyte}			{ tell_input(); value = ""; yybegin(YYINITIAL); t = new Token(Parser.FORCED_EOC, (String) value); return Parser.FORCED_EOC; }
<SELECT>{ws}				{ proto_input(yytext()); sel_stmt.append(yytext()); break; }
<SELECT>{with}				{ yypushback(yytext().length());  // we put "with" back to be read again
					  yybegin(YYINITIAL);
					  value = new String(sel_stmt);
					  t = new Token(Parser.SQLSELECT, (String) value, value);
					  return Parser.SQLSELECT;
					}
<SELECT>{nws_nsc}			{ proto_input(yytext()); sel_stmt.append(yytext()); break; }
<SELECT>\'				{ proto_input(yytext()); sel_stmt.append(yytext()); yybegin(SELECTSTR); break; }
<SELECT>;				{ yybegin(YYINITIAL);
					  yypushback(1);
					  value = new String(sel_stmt);
					  t = new Token(Parser.SQLSELECT, (String) value, value);
					  return Parser.SQLSELECT;
					}
<SELECT>"("				{ proto_input(yytext()); sel_stmt.append(yytext()); selbrctr++; break; }
<SELECT>")"				{ if (selbrctr == 0) {
						yybegin(YYINITIAL);
						yypushback(1);
					  	value = new String(sel_stmt);
						  t = new Token(Parser.SQLSELECT, (String) value, value);
						  return Parser.SQLSELECT;
					  } else
						selbrctr--;
					  proto_input(yytext());
					  sel_stmt.append(yytext());
					  break;
					}
<SELECT>{nulbyte}			{ tell_input(); value = ""; yybegin(YYINITIAL); t = new Token(Parser.FORCED_EOC, (String) value); return Parser.FORCED_EOC; }

<SELECTSTR>\'				{ proto_input(yytext()); sel_stmt.append(yytext()); yybegin(SELECT); break; }
<SELECTSTR>[^']+			{ proto_input(yytext()); sel_stmt.append(yytext()); break; }


